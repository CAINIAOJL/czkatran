// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: czkatran.proto
#ifndef GRPC_czkatran_2eproto__INCLUDED
#define GRPC_czkatran_2eproto__INCLUDED

#include "czkatran.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace lb {
namespace czkatran {

class czKatranService final {
 public:
  static constexpr char const* service_full_name() {
    return "lb.czkatran.czKatranService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status changeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncchangeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncchangeMacRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncchangeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncchangeMacRaw(context, request, cq));
    }
    virtual ::grpc::Status getMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Mac* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Mac>> AsyncgetMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Mac>>(AsyncgetMacRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Mac>> PrepareAsyncgetMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Mac>>(PrepareAsyncgetMacRaw(context, request, cq));
    }
    virtual ::grpc::Status addVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncaddVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncaddVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncaddVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncaddVipRaw(context, request, cq));
    }
    virtual ::grpc::Status delVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncdelVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncdelVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncdelVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncdelVipRaw(context, request, cq));
    }
    virtual ::grpc::Status getAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Vips* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Vips>> AsyncgetAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Vips>>(AsyncgetAllVipsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Vips>> PrepareAsyncgetAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Vips>>(PrepareAsyncgetAllVipsRaw(context, request, cq));
    }
    virtual ::grpc::Status modifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncmodifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncmodifyVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncmodifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncmodifyVipRaw(context, request, cq));
    }
    virtual ::grpc::Status modifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncmodifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncmodifyRealRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncmodifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncmodifyRealRaw(context, request, cq));
    }
    virtual ::grpc::Status getVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::lb::czkatran::Flags* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>> AsyncgetVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>>(AsyncgetVipFlagsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>> PrepareAsyncgetVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>>(PrepareAsyncgetVipFlagsRaw(context, request, cq));
    }
    virtual ::grpc::Status getRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::lb::czkatran::Flags* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>> AsyncgetRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>>(AsyncgetRealFlagsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>> PrepareAsyncgetRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>>(PrepareAsyncgetRealFlagsRaw(context, request, cq));
    }
    virtual ::grpc::Status addRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncaddRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncaddRealForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncaddRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncaddRealForVipRaw(context, request, cq));
    }
    virtual ::grpc::Status delRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncdelRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncdelRealForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncdelRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncdelRealForVipRaw(context, request, cq));
    }
    virtual ::grpc::Status modifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncmodifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncmodifyRealsForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncmodifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncmodifyRealsForVipRaw(context, request, cq));
    }
    virtual ::grpc::Status getRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::lb::czkatran::Reals* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Reals>> AsyncgetRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Reals>>(AsyncgetRealsForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Reals>> PrepareAsyncgetRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Reals>>(PrepareAsyncgetRealsForVipRaw(context, request, cq));
    }
    virtual ::grpc::Status modifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncmodifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncmodifyQuicRealsMappingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncmodifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncmodifyQuicRealsMappingRaw(context, request, cq));
    }
    virtual ::grpc::Status getQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::QuicReals* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::QuicReals>> AsyncgetQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::QuicReals>>(AsyncgetQuicRealsMappingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::QuicReals>> PrepareAsyncgetQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::QuicReals>>(PrepareAsyncgetQuicRealsMappingRaw(context, request, cq));
    }
    virtual ::grpc::Status getStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::lb::czkatran::Stats* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> AsyncgetStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(AsyncgetStatsForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> PrepareAsyncgetStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(PrepareAsyncgetStatsForVipRaw(context, request, cq));
    }
    virtual ::grpc::Status getLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Stats* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> AsyncgetLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(AsyncgetLruStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> PrepareAsyncgetLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(PrepareAsyncgetLruStatsRaw(context, request, cq));
    }
    virtual ::grpc::Status getLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Stats* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> AsyncgetLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(AsyncgetLruMissStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> PrepareAsyncgetLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(PrepareAsyncgetLruMissStatsRaw(context, request, cq));
    }
    virtual ::grpc::Status getLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Stats* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> AsyncgetLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(AsyncgetLruFailbackStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> PrepareAsyncgetLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(PrepareAsyncgetLruFailbackStatsRaw(context, request, cq));
    }
    virtual ::grpc::Status getIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Stats* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> AsyncgetIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(AsyncgetIcmpTooBigStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>> PrepareAsyncgetIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>>(PrepareAsyncgetIcmpTooBigStatsRaw(context, request, cq));
    }
    virtual ::grpc::Status addHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncaddHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncaddHealthcheckerDstRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncaddHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncaddHealthcheckerDstRaw(context, request, cq));
    }
    virtual ::grpc::Status delHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::lb::czkatran::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> AsyncdelHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(AsyncdelHealthcheckerDstRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>> PrepareAsyncdelHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>>(PrepareAsyncdelHealthcheckerDstRaw(context, request, cq));
    }
    virtual ::grpc::Status getHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::hcMap* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::hcMap>> AsyncgetHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::hcMap>>(AsyncgetHealthcheckersDstRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::hcMap>> PrepareAsyncgetHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::hcMap>>(PrepareAsyncgetHealthcheckersDstRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void changeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void changeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Mac* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Mac* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void addVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void addVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void delVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void delVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Vips* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Vips* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void modifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void modifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Flags* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Flags* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real* request, ::lb::czkatran::Flags* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real* request, ::lb::czkatran::Flags* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void addRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void addRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void delRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void delRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void modifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Reals* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Reals* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void modifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::QuicReals* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::QuicReals* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void addHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void addHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void delHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void delHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::hcMap* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::hcMap* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncchangeMacRaw(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncchangeMacRaw(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Mac>* AsyncgetMacRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Mac>* PrepareAsyncgetMacRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncaddVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncaddVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncdelVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncdelVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Vips>* AsyncgetAllVipsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Vips>* PrepareAsyncgetAllVipsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncmodifyVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncmodifyVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncmodifyRealRaw(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncmodifyRealRaw(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>* AsyncgetVipFlagsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>* PrepareAsyncgetVipFlagsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>* AsyncgetRealFlagsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Flags>* PrepareAsyncgetRealFlagsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncaddRealForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncaddRealForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncdelRealForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncdelRealForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncmodifyRealsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncmodifyRealsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Reals>* AsyncgetRealsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Reals>* PrepareAsyncgetRealsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncmodifyQuicRealsMappingRaw(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncmodifyQuicRealsMappingRaw(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::QuicReals>* AsyncgetQuicRealsMappingRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::QuicReals>* PrepareAsyncgetQuicRealsMappingRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* AsyncgetStatsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* PrepareAsyncgetStatsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* AsyncgetLruStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* PrepareAsyncgetLruStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* AsyncgetLruMissStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* PrepareAsyncgetLruMissStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* AsyncgetLruFailbackStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* PrepareAsyncgetLruFailbackStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* AsyncgetIcmpTooBigStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Stats>* PrepareAsyncgetIcmpTooBigStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncaddHealthcheckerDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncaddHealthcheckerDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* AsyncdelHealthcheckerDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::Bool>* PrepareAsyncdelHealthcheckerDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::hcMap>* AsyncgetHealthcheckersDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::lb::czkatran::hcMap>* PrepareAsyncgetHealthcheckersDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status changeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncchangeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncchangeMacRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncchangeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncchangeMacRaw(context, request, cq));
    }
    ::grpc::Status getMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Mac* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Mac>> AsyncgetMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Mac>>(AsyncgetMacRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Mac>> PrepareAsyncgetMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Mac>>(PrepareAsyncgetMacRaw(context, request, cq));
    }
    ::grpc::Status addVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncaddVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncaddVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncaddVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncaddVipRaw(context, request, cq));
    }
    ::grpc::Status delVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncdelVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncdelVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncdelVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncdelVipRaw(context, request, cq));
    }
    ::grpc::Status getAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Vips* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Vips>> AsyncgetAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Vips>>(AsyncgetAllVipsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Vips>> PrepareAsyncgetAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Vips>>(PrepareAsyncgetAllVipsRaw(context, request, cq));
    }
    ::grpc::Status modifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncmodifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncmodifyVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncmodifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncmodifyVipRaw(context, request, cq));
    }
    ::grpc::Status modifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncmodifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncmodifyRealRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncmodifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncmodifyRealRaw(context, request, cq));
    }
    ::grpc::Status getVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::lb::czkatran::Flags* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>> AsyncgetVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>>(AsyncgetVipFlagsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>> PrepareAsyncgetVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>>(PrepareAsyncgetVipFlagsRaw(context, request, cq));
    }
    ::grpc::Status getRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::lb::czkatran::Flags* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>> AsyncgetRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>>(AsyncgetRealFlagsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>> PrepareAsyncgetRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>>(PrepareAsyncgetRealFlagsRaw(context, request, cq));
    }
    ::grpc::Status addRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncaddRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncaddRealForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncaddRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncaddRealForVipRaw(context, request, cq));
    }
    ::grpc::Status delRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncdelRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncdelRealForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncdelRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncdelRealForVipRaw(context, request, cq));
    }
    ::grpc::Status modifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncmodifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncmodifyRealsForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncmodifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncmodifyRealsForVipRaw(context, request, cq));
    }
    ::grpc::Status getRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::lb::czkatran::Reals* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Reals>> AsyncgetRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Reals>>(AsyncgetRealsForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Reals>> PrepareAsyncgetRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Reals>>(PrepareAsyncgetRealsForVipRaw(context, request, cq));
    }
    ::grpc::Status modifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncmodifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncmodifyQuicRealsMappingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncmodifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncmodifyQuicRealsMappingRaw(context, request, cq));
    }
    ::grpc::Status getQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::QuicReals* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::QuicReals>> AsyncgetQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::QuicReals>>(AsyncgetQuicRealsMappingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::QuicReals>> PrepareAsyncgetQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::QuicReals>>(PrepareAsyncgetQuicRealsMappingRaw(context, request, cq));
    }
    ::grpc::Status getStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::lb::czkatran::Stats* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> AsyncgetStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(AsyncgetStatsForVipRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> PrepareAsyncgetStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(PrepareAsyncgetStatsForVipRaw(context, request, cq));
    }
    ::grpc::Status getLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Stats* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> AsyncgetLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(AsyncgetLruStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> PrepareAsyncgetLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(PrepareAsyncgetLruStatsRaw(context, request, cq));
    }
    ::grpc::Status getLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Stats* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> AsyncgetLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(AsyncgetLruMissStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> PrepareAsyncgetLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(PrepareAsyncgetLruMissStatsRaw(context, request, cq));
    }
    ::grpc::Status getLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Stats* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> AsyncgetLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(AsyncgetLruFailbackStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> PrepareAsyncgetLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(PrepareAsyncgetLruFailbackStatsRaw(context, request, cq));
    }
    ::grpc::Status getIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::Stats* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> AsyncgetIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(AsyncgetIcmpTooBigStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>> PrepareAsyncgetIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>>(PrepareAsyncgetIcmpTooBigStatsRaw(context, request, cq));
    }
    ::grpc::Status addHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncaddHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncaddHealthcheckerDstRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncaddHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncaddHealthcheckerDstRaw(context, request, cq));
    }
    ::grpc::Status delHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::lb::czkatran::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> AsyncdelHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(AsyncdelHealthcheckerDstRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>> PrepareAsyncdelHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>>(PrepareAsyncdelHealthcheckerDstRaw(context, request, cq));
    }
    ::grpc::Status getHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::lb::czkatran::hcMap* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::hcMap>> AsyncgetHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::hcMap>>(AsyncgetHealthcheckersDstRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::hcMap>> PrepareAsyncgetHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::lb::czkatran::hcMap>>(PrepareAsyncgetHealthcheckersDstRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void changeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void changeMac(::grpc::ClientContext* context, const ::lb::czkatran::Mac* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Mac* response, std::function<void(::grpc::Status)>) override;
      void getMac(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Mac* response, ::grpc::ClientUnaryReactor* reactor) override;
      void addVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void addVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void delVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void delVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Vips* response, std::function<void(::grpc::Status)>) override;
      void getAllVips(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Vips* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void modifyVip(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void modifyReal(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Flags* response, std::function<void(::grpc::Status)>) override;
      void getVipFlags(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Flags* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real* request, ::lb::czkatran::Flags* response, std::function<void(::grpc::Status)>) override;
      void getRealFlags(::grpc::ClientContext* context, const ::lb::czkatran::Real* request, ::lb::czkatran::Flags* response, ::grpc::ClientUnaryReactor* reactor) override;
      void addRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void addRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void delRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void delRealForVip(::grpc::ClientContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void modifyRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Reals* response, std::function<void(::grpc::Status)>) override;
      void getRealsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Reals* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void modifyQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::QuicReals* response, std::function<void(::grpc::Status)>) override;
      void getQuicRealsMapping(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::QuicReals* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) override;
      void getStatsForVip(::grpc::ClientContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) override;
      void getLruStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) override;
      void getLruMissStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) override;
      void getLruFailbackStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, std::function<void(::grpc::Status)>) override;
      void getIcmpTooBigStats(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response, ::grpc::ClientUnaryReactor* reactor) override;
      void addHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void addHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void delHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark* request, ::lb::czkatran::Bool* response, std::function<void(::grpc::Status)>) override;
      void delHealthcheckerDst(::grpc::ClientContext* context, const ::lb::czkatran::Somark* request, ::lb::czkatran::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::hcMap* response, std::function<void(::grpc::Status)>) override;
      void getHealthcheckersDst(::grpc::ClientContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::hcMap* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncchangeMacRaw(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncchangeMacRaw(::grpc::ClientContext* context, const ::lb::czkatran::Mac& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Mac>* AsyncgetMacRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Mac>* PrepareAsyncgetMacRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncaddVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncaddVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncdelVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncdelVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Vips>* AsyncgetAllVipsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Vips>* PrepareAsyncgetAllVipsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncmodifyVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncmodifyVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::VipMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncmodifyRealRaw(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncmodifyRealRaw(::grpc::ClientContext* context, const ::lb::czkatran::RealMeta& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>* AsyncgetVipFlagsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>* PrepareAsyncgetVipFlagsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>* AsyncgetRealFlagsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Flags>* PrepareAsyncgetRealFlagsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Real& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncaddRealForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncaddRealForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncdelRealForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncdelRealForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::realForVip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncmodifyRealsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncmodifyRealsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedRealForVip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Reals>* AsyncgetRealsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Reals>* PrepareAsyncgetRealsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncmodifyQuicRealsMappingRaw(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncmodifyQuicRealsMappingRaw(::grpc::ClientContext* context, const ::lb::czkatran::ModifiedQuicReals& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::QuicReals>* AsyncgetQuicRealsMappingRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::QuicReals>* PrepareAsyncgetQuicRealsMappingRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* AsyncgetStatsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* PrepareAsyncgetStatsForVipRaw(::grpc::ClientContext* context, const ::lb::czkatran::Vip& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* AsyncgetLruStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* PrepareAsyncgetLruStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* AsyncgetLruMissStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* PrepareAsyncgetLruMissStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* AsyncgetLruFailbackStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* PrepareAsyncgetLruFailbackStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* AsyncgetIcmpTooBigStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Stats>* PrepareAsyncgetIcmpTooBigStatsRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncaddHealthcheckerDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncaddHealthcheckerDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Healthcheck& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* AsyncdelHealthcheckerDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::Bool>* PrepareAsyncdelHealthcheckerDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Somark& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::hcMap>* AsyncgetHealthcheckersDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::lb::czkatran::hcMap>* PrepareAsyncgetHealthcheckersDstRaw(::grpc::ClientContext* context, const ::lb::czkatran::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_changeMac_;
    const ::grpc::internal::RpcMethod rpcmethod_getMac_;
    const ::grpc::internal::RpcMethod rpcmethod_addVip_;
    const ::grpc::internal::RpcMethod rpcmethod_delVip_;
    const ::grpc::internal::RpcMethod rpcmethod_getAllVips_;
    const ::grpc::internal::RpcMethod rpcmethod_modifyVip_;
    const ::grpc::internal::RpcMethod rpcmethod_modifyReal_;
    const ::grpc::internal::RpcMethod rpcmethod_getVipFlags_;
    const ::grpc::internal::RpcMethod rpcmethod_getRealFlags_;
    const ::grpc::internal::RpcMethod rpcmethod_addRealForVip_;
    const ::grpc::internal::RpcMethod rpcmethod_delRealForVip_;
    const ::grpc::internal::RpcMethod rpcmethod_modifyRealsForVip_;
    const ::grpc::internal::RpcMethod rpcmethod_getRealsForVip_;
    const ::grpc::internal::RpcMethod rpcmethod_modifyQuicRealsMapping_;
    const ::grpc::internal::RpcMethod rpcmethod_getQuicRealsMapping_;
    const ::grpc::internal::RpcMethod rpcmethod_getStatsForVip_;
    const ::grpc::internal::RpcMethod rpcmethod_getLruStats_;
    const ::grpc::internal::RpcMethod rpcmethod_getLruMissStats_;
    const ::grpc::internal::RpcMethod rpcmethod_getLruFailbackStats_;
    const ::grpc::internal::RpcMethod rpcmethod_getIcmpTooBigStats_;
    const ::grpc::internal::RpcMethod rpcmethod_addHealthcheckerDst_;
    const ::grpc::internal::RpcMethod rpcmethod_delHealthcheckerDst_;
    const ::grpc::internal::RpcMethod rpcmethod_getHealthcheckersDst_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status changeMac(::grpc::ServerContext* context, const ::lb::czkatran::Mac* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status getMac(::grpc::ServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Mac* response);
    virtual ::grpc::Status addVip(::grpc::ServerContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status delVip(::grpc::ServerContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status getAllVips(::grpc::ServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Vips* response);
    virtual ::grpc::Status modifyVip(::grpc::ServerContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status modifyReal(::grpc::ServerContext* context, const ::lb::czkatran::RealMeta* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status getVipFlags(::grpc::ServerContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Flags* response);
    virtual ::grpc::Status getRealFlags(::grpc::ServerContext* context, const ::lb::czkatran::Real* request, ::lb::czkatran::Flags* response);
    virtual ::grpc::Status addRealForVip(::grpc::ServerContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status delRealForVip(::grpc::ServerContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status modifyRealsForVip(::grpc::ServerContext* context, const ::lb::czkatran::ModifiedRealForVip* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status getRealsForVip(::grpc::ServerContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Reals* response);
    virtual ::grpc::Status modifyQuicRealsMapping(::grpc::ServerContext* context, const ::lb::czkatran::ModifiedQuicReals* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status getQuicRealsMapping(::grpc::ServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::QuicReals* response);
    virtual ::grpc::Status getStatsForVip(::grpc::ServerContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Stats* response);
    virtual ::grpc::Status getLruStats(::grpc::ServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response);
    virtual ::grpc::Status getLruMissStats(::grpc::ServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response);
    virtual ::grpc::Status getLruFailbackStats(::grpc::ServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response);
    virtual ::grpc::Status getIcmpTooBigStats(::grpc::ServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response);
    virtual ::grpc::Status addHealthcheckerDst(::grpc::ServerContext* context, const ::lb::czkatran::Healthcheck* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status delHealthcheckerDst(::grpc::ServerContext* context, const ::lb::czkatran::Somark* request, ::lb::czkatran::Bool* response);
    virtual ::grpc::Status getHealthcheckersDst(::grpc::ServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::hcMap* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_changeMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_changeMac() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_changeMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status changeMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Mac* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestchangeMac(::grpc::ServerContext* context, ::lb::czkatran::Mac* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getMac() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_getMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Mac* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMac(::grpc::ServerContext* context, ::lb::czkatran::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Mac>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_addVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_addVip() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_addVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestaddVip(::grpc::ServerContext* context, ::lb::czkatran::VipMeta* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_delVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_delVip() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_delVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdelVip(::grpc::ServerContext* context, ::lb::czkatran::Vip* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getAllVips : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getAllVips() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_getAllVips() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllVips(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Vips* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAllVips(::grpc::ServerContext* context, ::lb::czkatran::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Vips>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modifyVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modifyVip() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_modifyVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyVip(::grpc::ServerContext* context, ::lb::czkatran::VipMeta* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modifyReal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modifyReal() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_modifyReal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyReal(::grpc::ServerContext* /*context*/, const ::lb::czkatran::RealMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyReal(::grpc::ServerContext* context, ::lb::czkatran::RealMeta* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getVipFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getVipFlags() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_getVipFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVipFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetVipFlags(::grpc::ServerContext* context, ::lb::czkatran::Vip* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Flags>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRealFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRealFlags() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_getRealFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Real* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRealFlags(::grpc::ServerContext* context, ::lb::czkatran::Real* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Flags>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_addRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_addRealForVip() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_addRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestaddRealForVip(::grpc::ServerContext* context, ::lb::czkatran::realForVip* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_delRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_delRealForVip() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_delRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdelRealForVip(::grpc::ServerContext* context, ::lb::czkatran::realForVip* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modifyRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modifyRealsForVip() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_modifyRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedRealForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyRealsForVip(::grpc::ServerContext* context, ::lb::czkatran::ModifiedRealForVip* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRealsForVip() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_getRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Reals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRealsForVip(::grpc::ServerContext* context, ::lb::czkatran::Vip* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Reals>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modifyQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modifyQuicRealsMapping() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_modifyQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedQuicReals* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyQuicRealsMapping(::grpc::ServerContext* context, ::lb::czkatran::ModifiedQuicReals* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getQuicRealsMapping() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_getQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::QuicReals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetQuicRealsMapping(::grpc::ServerContext* context, ::lb::czkatran::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::QuicReals>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getStatsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getStatsForVip() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_getStatsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatsForVip(::grpc::ServerContext* context, ::lb::czkatran::Vip* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Stats>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getLruStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getLruStats() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_getLruStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLruStats(::grpc::ServerContext* context, ::lb::czkatran::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Stats>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getLruMissStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getLruMissStats() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_getLruMissStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruMissStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLruMissStats(::grpc::ServerContext* context, ::lb::czkatran::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Stats>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getLruFailbackStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getLruFailbackStats() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_getLruFailbackStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruFailbackStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLruFailbackStats(::grpc::ServerContext* context, ::lb::czkatran::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Stats>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getIcmpTooBigStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getIcmpTooBigStats() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_getIcmpTooBigStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getIcmpTooBigStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetIcmpTooBigStats(::grpc::ServerContext* context, ::lb::czkatran::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Stats>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_addHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_addHealthcheckerDst() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_addHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Healthcheck* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestaddHealthcheckerDst(::grpc::ServerContext* context, ::lb::czkatran::Healthcheck* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_delHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_delHealthcheckerDst() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_delHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Somark* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdelHealthcheckerDst(::grpc::ServerContext* context, ::lb::czkatran::Somark* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getHealthcheckersDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getHealthcheckersDst() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_getHealthcheckersDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getHealthcheckersDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::hcMap* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetHealthcheckersDst(::grpc::ServerContext* context, ::lb::czkatran::Empty* request, ::grpc::ServerAsyncResponseWriter< ::lb::czkatran::hcMap>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_changeMac<WithAsyncMethod_getMac<WithAsyncMethod_addVip<WithAsyncMethod_delVip<WithAsyncMethod_getAllVips<WithAsyncMethod_modifyVip<WithAsyncMethod_modifyReal<WithAsyncMethod_getVipFlags<WithAsyncMethod_getRealFlags<WithAsyncMethod_addRealForVip<WithAsyncMethod_delRealForVip<WithAsyncMethod_modifyRealsForVip<WithAsyncMethod_getRealsForVip<WithAsyncMethod_modifyQuicRealsMapping<WithAsyncMethod_getQuicRealsMapping<WithAsyncMethod_getStatsForVip<WithAsyncMethod_getLruStats<WithAsyncMethod_getLruMissStats<WithAsyncMethod_getLruFailbackStats<WithAsyncMethod_getIcmpTooBigStats<WithAsyncMethod_addHealthcheckerDst<WithAsyncMethod_delHealthcheckerDst<WithAsyncMethod_getHealthcheckersDst<Service > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_changeMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_changeMac() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Mac, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Mac* request, ::lb::czkatran::Bool* response) { return this->changeMac(context, request, response); }));}
    void SetMessageAllocatorFor_changeMac(
        ::grpc::MessageAllocator< ::lb::czkatran::Mac, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Mac, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_changeMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status changeMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Mac* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* changeMac(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Mac* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getMac() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Mac>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Mac* response) { return this->getMac(context, request, response); }));}
    void SetMessageAllocatorFor_getMac(
        ::grpc::MessageAllocator< ::lb::czkatran::Empty, ::lb::czkatran::Mac>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Mac>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Mac* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getMac(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Mac* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_addVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_addVip() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response) { return this->addVip(context, request, response); }));}
    void SetMessageAllocatorFor_addVip(
        ::grpc::MessageAllocator< ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_addVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* addVip(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_delVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_delVip() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Vip, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Bool* response) { return this->delVip(context, request, response); }));}
    void SetMessageAllocatorFor_delVip(
        ::grpc::MessageAllocator< ::lb::czkatran::Vip, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Vip, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_delVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delVip(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getAllVips : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getAllVips() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Vips>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Vips* response) { return this->getAllVips(context, request, response); }));}
    void SetMessageAllocatorFor_getAllVips(
        ::grpc::MessageAllocator< ::lb::czkatran::Empty, ::lb::czkatran::Vips>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Vips>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getAllVips() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllVips(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Vips* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAllVips(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Vips* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modifyVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modifyVip() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::VipMeta* request, ::lb::czkatran::Bool* response) { return this->modifyVip(context, request, response); }));}
    void SetMessageAllocatorFor_modifyVip(
        ::grpc::MessageAllocator< ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modifyVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyVip(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modifyReal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modifyReal() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::RealMeta, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::RealMeta* request, ::lb::czkatran::Bool* response) { return this->modifyReal(context, request, response); }));}
    void SetMessageAllocatorFor_modifyReal(
        ::grpc::MessageAllocator< ::lb::czkatran::RealMeta, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::RealMeta, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modifyReal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyReal(::grpc::ServerContext* /*context*/, const ::lb::czkatran::RealMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyReal(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::RealMeta* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getVipFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getVipFlags() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Vip, ::lb::czkatran::Flags>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Flags* response) { return this->getVipFlags(context, request, response); }));}
    void SetMessageAllocatorFor_getVipFlags(
        ::grpc::MessageAllocator< ::lb::czkatran::Vip, ::lb::czkatran::Flags>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Vip, ::lb::czkatran::Flags>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getVipFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVipFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getVipFlags(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Flags* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRealFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRealFlags() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Real, ::lb::czkatran::Flags>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Real* request, ::lb::czkatran::Flags* response) { return this->getRealFlags(context, request, response); }));}
    void SetMessageAllocatorFor_getRealFlags(
        ::grpc::MessageAllocator< ::lb::czkatran::Real, ::lb::czkatran::Flags>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Real, ::lb::czkatran::Flags>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRealFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Real* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRealFlags(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Real* /*request*/, ::lb::czkatran::Flags* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_addRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_addRealForVip() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::realForVip, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response) { return this->addRealForVip(context, request, response); }));}
    void SetMessageAllocatorFor_addRealForVip(
        ::grpc::MessageAllocator< ::lb::czkatran::realForVip, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::realForVip, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_addRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* addRealForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_delRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_delRealForVip() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::realForVip, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::realForVip* request, ::lb::czkatran::Bool* response) { return this->delRealForVip(context, request, response); }));}
    void SetMessageAllocatorFor_delRealForVip(
        ::grpc::MessageAllocator< ::lb::czkatran::realForVip, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::realForVip, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_delRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delRealForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modifyRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modifyRealsForVip() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::ModifiedRealForVip, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::ModifiedRealForVip* request, ::lb::czkatran::Bool* response) { return this->modifyRealsForVip(context, request, response); }));}
    void SetMessageAllocatorFor_modifyRealsForVip(
        ::grpc::MessageAllocator< ::lb::czkatran::ModifiedRealForVip, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::ModifiedRealForVip, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modifyRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedRealForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyRealsForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::ModifiedRealForVip* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRealsForVip() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Vip, ::lb::czkatran::Reals>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Reals* response) { return this->getRealsForVip(context, request, response); }));}
    void SetMessageAllocatorFor_getRealsForVip(
        ::grpc::MessageAllocator< ::lb::czkatran::Vip, ::lb::czkatran::Reals>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Vip, ::lb::czkatran::Reals>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Reals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRealsForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Reals* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modifyQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modifyQuicRealsMapping() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::ModifiedQuicReals, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::ModifiedQuicReals* request, ::lb::czkatran::Bool* response) { return this->modifyQuicRealsMapping(context, request, response); }));}
    void SetMessageAllocatorFor_modifyQuicRealsMapping(
        ::grpc::MessageAllocator< ::lb::czkatran::ModifiedQuicReals, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::ModifiedQuicReals, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modifyQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedQuicReals* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyQuicRealsMapping(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::ModifiedQuicReals* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getQuicRealsMapping() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::QuicReals>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::QuicReals* response) { return this->getQuicRealsMapping(context, request, response); }));}
    void SetMessageAllocatorFor_getQuicRealsMapping(
        ::grpc::MessageAllocator< ::lb::czkatran::Empty, ::lb::czkatran::QuicReals>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::QuicReals>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::QuicReals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getQuicRealsMapping(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::QuicReals* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getStatsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getStatsForVip() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Vip, ::lb::czkatran::Stats>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Vip* request, ::lb::czkatran::Stats* response) { return this->getStatsForVip(context, request, response); }));}
    void SetMessageAllocatorFor_getStatsForVip(
        ::grpc::MessageAllocator< ::lb::czkatran::Vip, ::lb::czkatran::Stats>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Vip, ::lb::czkatran::Stats>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getStatsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getStatsForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Stats* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getLruStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getLruStats() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Stats>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response) { return this->getLruStats(context, request, response); }));}
    void SetMessageAllocatorFor_getLruStats(
        ::grpc::MessageAllocator< ::lb::czkatran::Empty, ::lb::czkatran::Stats>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Stats>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getLruStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getLruStats(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getLruMissStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getLruMissStats() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Stats>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response) { return this->getLruMissStats(context, request, response); }));}
    void SetMessageAllocatorFor_getLruMissStats(
        ::grpc::MessageAllocator< ::lb::czkatran::Empty, ::lb::czkatran::Stats>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Stats>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getLruMissStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruMissStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getLruMissStats(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getLruFailbackStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getLruFailbackStats() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Stats>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response) { return this->getLruFailbackStats(context, request, response); }));}
    void SetMessageAllocatorFor_getLruFailbackStats(
        ::grpc::MessageAllocator< ::lb::czkatran::Empty, ::lb::czkatran::Stats>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Stats>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getLruFailbackStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruFailbackStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getLruFailbackStats(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getIcmpTooBigStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getIcmpTooBigStats() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Stats>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::Stats* response) { return this->getIcmpTooBigStats(context, request, response); }));}
    void SetMessageAllocatorFor_getIcmpTooBigStats(
        ::grpc::MessageAllocator< ::lb::czkatran::Empty, ::lb::czkatran::Stats>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::Stats>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getIcmpTooBigStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getIcmpTooBigStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getIcmpTooBigStats(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_addHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_addHealthcheckerDst() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Healthcheck, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Healthcheck* request, ::lb::czkatran::Bool* response) { return this->addHealthcheckerDst(context, request, response); }));}
    void SetMessageAllocatorFor_addHealthcheckerDst(
        ::grpc::MessageAllocator< ::lb::czkatran::Healthcheck, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Healthcheck, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_addHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Healthcheck* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* addHealthcheckerDst(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Healthcheck* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_delHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_delHealthcheckerDst() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Somark, ::lb::czkatran::Bool>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Somark* request, ::lb::czkatran::Bool* response) { return this->delHealthcheckerDst(context, request, response); }));}
    void SetMessageAllocatorFor_delHealthcheckerDst(
        ::grpc::MessageAllocator< ::lb::czkatran::Somark, ::lb::czkatran::Bool>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Somark, ::lb::czkatran::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_delHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Somark* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delHealthcheckerDst(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Somark* /*request*/, ::lb::czkatran::Bool* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getHealthcheckersDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getHealthcheckersDst() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::hcMap>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::lb::czkatran::Empty* request, ::lb::czkatran::hcMap* response) { return this->getHealthcheckersDst(context, request, response); }));}
    void SetMessageAllocatorFor_getHealthcheckersDst(
        ::grpc::MessageAllocator< ::lb::czkatran::Empty, ::lb::czkatran::hcMap>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::lb::czkatran::Empty, ::lb::czkatran::hcMap>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getHealthcheckersDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getHealthcheckersDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::hcMap* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getHealthcheckersDst(
      ::grpc::CallbackServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::hcMap* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_changeMac<WithCallbackMethod_getMac<WithCallbackMethod_addVip<WithCallbackMethod_delVip<WithCallbackMethod_getAllVips<WithCallbackMethod_modifyVip<WithCallbackMethod_modifyReal<WithCallbackMethod_getVipFlags<WithCallbackMethod_getRealFlags<WithCallbackMethod_addRealForVip<WithCallbackMethod_delRealForVip<WithCallbackMethod_modifyRealsForVip<WithCallbackMethod_getRealsForVip<WithCallbackMethod_modifyQuicRealsMapping<WithCallbackMethod_getQuicRealsMapping<WithCallbackMethod_getStatsForVip<WithCallbackMethod_getLruStats<WithCallbackMethod_getLruMissStats<WithCallbackMethod_getLruFailbackStats<WithCallbackMethod_getIcmpTooBigStats<WithCallbackMethod_addHealthcheckerDst<WithCallbackMethod_delHealthcheckerDst<WithCallbackMethod_getHealthcheckersDst<Service > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_changeMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_changeMac() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_changeMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status changeMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Mac* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getMac() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_getMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Mac* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_addVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_addVip() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_addVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_delVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_delVip() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_delVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getAllVips : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getAllVips() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_getAllVips() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllVips(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Vips* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modifyVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modifyVip() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_modifyVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modifyReal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modifyReal() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_modifyReal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyReal(::grpc::ServerContext* /*context*/, const ::lb::czkatran::RealMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getVipFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getVipFlags() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_getVipFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVipFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRealFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRealFlags() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_getRealFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Real* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_addRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_addRealForVip() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_addRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_delRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_delRealForVip() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_delRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modifyRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modifyRealsForVip() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_modifyRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedRealForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRealsForVip() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_getRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Reals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modifyQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modifyQuicRealsMapping() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_modifyQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedQuicReals* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getQuicRealsMapping() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_getQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::QuicReals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getStatsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getStatsForVip() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_getStatsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getLruStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getLruStats() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_getLruStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getLruMissStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getLruMissStats() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_getLruMissStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruMissStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getLruFailbackStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getLruFailbackStats() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_getLruFailbackStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruFailbackStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getIcmpTooBigStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getIcmpTooBigStats() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_getIcmpTooBigStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getIcmpTooBigStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_addHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_addHealthcheckerDst() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_addHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Healthcheck* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_delHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_delHealthcheckerDst() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_delHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Somark* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getHealthcheckersDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getHealthcheckersDst() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_getHealthcheckersDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getHealthcheckersDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::hcMap* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_changeMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_changeMac() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_changeMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status changeMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Mac* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestchangeMac(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getMac() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_getMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Mac* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMac(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_addVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_addVip() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_addVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestaddVip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_delVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_delVip() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_delVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdelVip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getAllVips : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getAllVips() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_getAllVips() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllVips(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Vips* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAllVips(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modifyVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modifyVip() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_modifyVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyVip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modifyReal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modifyReal() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_modifyReal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyReal(::grpc::ServerContext* /*context*/, const ::lb::czkatran::RealMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyReal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getVipFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getVipFlags() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_getVipFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVipFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetVipFlags(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRealFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRealFlags() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_getRealFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Real* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRealFlags(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_addRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_addRealForVip() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_addRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestaddRealForVip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_delRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_delRealForVip() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_delRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdelRealForVip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modifyRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modifyRealsForVip() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_modifyRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedRealForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyRealsForVip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRealsForVip() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_getRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Reals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRealsForVip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modifyQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modifyQuicRealsMapping() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_modifyQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedQuicReals* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodifyQuicRealsMapping(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getQuicRealsMapping() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_getQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::QuicReals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetQuicRealsMapping(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getStatsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getStatsForVip() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_getStatsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetStatsForVip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getLruStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getLruStats() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_getLruStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLruStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getLruMissStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getLruMissStats() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_getLruMissStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruMissStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLruMissStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getLruFailbackStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getLruFailbackStats() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_getLruFailbackStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruFailbackStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLruFailbackStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getIcmpTooBigStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getIcmpTooBigStats() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_getIcmpTooBigStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getIcmpTooBigStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetIcmpTooBigStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_addHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_addHealthcheckerDst() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_addHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Healthcheck* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestaddHealthcheckerDst(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_delHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_delHealthcheckerDst() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_delHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Somark* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdelHealthcheckerDst(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getHealthcheckersDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getHealthcheckersDst() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_getHealthcheckersDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getHealthcheckersDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::hcMap* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetHealthcheckersDst(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_changeMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_changeMac() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->changeMac(context, request, response); }));
    }
    ~WithRawCallbackMethod_changeMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status changeMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Mac* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* changeMac(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getMac() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getMac(context, request, response); }));
    }
    ~WithRawCallbackMethod_getMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Mac* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getMac(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_addVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_addVip() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->addVip(context, request, response); }));
    }
    ~WithRawCallbackMethod_addVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* addVip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_delVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_delVip() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->delVip(context, request, response); }));
    }
    ~WithRawCallbackMethod_delVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delVip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getAllVips : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getAllVips() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getAllVips(context, request, response); }));
    }
    ~WithRawCallbackMethod_getAllVips() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllVips(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Vips* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAllVips(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modifyVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modifyVip() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modifyVip(context, request, response); }));
    }
    ~WithRawCallbackMethod_modifyVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyVip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modifyReal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modifyReal() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modifyReal(context, request, response); }));
    }
    ~WithRawCallbackMethod_modifyReal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyReal(::grpc::ServerContext* /*context*/, const ::lb::czkatran::RealMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyReal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getVipFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getVipFlags() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getVipFlags(context, request, response); }));
    }
    ~WithRawCallbackMethod_getVipFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getVipFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getVipFlags(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRealFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRealFlags() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRealFlags(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRealFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Real* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRealFlags(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_addRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_addRealForVip() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->addRealForVip(context, request, response); }));
    }
    ~WithRawCallbackMethod_addRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* addRealForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_delRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_delRealForVip() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->delRealForVip(context, request, response); }));
    }
    ~WithRawCallbackMethod_delRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delRealForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modifyRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modifyRealsForVip() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modifyRealsForVip(context, request, response); }));
    }
    ~WithRawCallbackMethod_modifyRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedRealForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyRealsForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRealsForVip() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRealsForVip(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Reals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRealsForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modifyQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modifyQuicRealsMapping() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modifyQuicRealsMapping(context, request, response); }));
    }
    ~WithRawCallbackMethod_modifyQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modifyQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedQuicReals* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modifyQuicRealsMapping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getQuicRealsMapping() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getQuicRealsMapping(context, request, response); }));
    }
    ~WithRawCallbackMethod_getQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::QuicReals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getQuicRealsMapping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getStatsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getStatsForVip() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getStatsForVip(context, request, response); }));
    }
    ~WithRawCallbackMethod_getStatsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getStatsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getStatsForVip(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getLruStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getLruStats() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getLruStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_getLruStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getLruStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getLruMissStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getLruMissStats() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getLruMissStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_getLruMissStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruMissStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getLruMissStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getLruFailbackStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getLruFailbackStats() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getLruFailbackStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_getLruFailbackStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLruFailbackStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getLruFailbackStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getIcmpTooBigStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getIcmpTooBigStats() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getIcmpTooBigStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_getIcmpTooBigStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getIcmpTooBigStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getIcmpTooBigStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_addHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_addHealthcheckerDst() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->addHealthcheckerDst(context, request, response); }));
    }
    ~WithRawCallbackMethod_addHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Healthcheck* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* addHealthcheckerDst(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_delHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_delHealthcheckerDst() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->delHealthcheckerDst(context, request, response); }));
    }
    ~WithRawCallbackMethod_delHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status delHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Somark* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* delHealthcheckerDst(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getHealthcheckersDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getHealthcheckersDst() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getHealthcheckersDst(context, request, response); }));
    }
    ~WithRawCallbackMethod_getHealthcheckersDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getHealthcheckersDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::hcMap* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getHealthcheckersDst(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_changeMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_changeMac() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Mac, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Mac, ::lb::czkatran::Bool>* streamer) {
                       return this->StreamedchangeMac(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_changeMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status changeMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Mac* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedchangeMac(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Mac,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getMac : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getMac() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Empty, ::lb::czkatran::Mac>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Empty, ::lb::czkatran::Mac>* streamer) {
                       return this->StreamedgetMac(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getMac() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getMac(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Mac* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetMac(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Empty,::lb::czkatran::Mac>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_addVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_addVip() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>* streamer) {
                       return this->StreamedaddVip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_addVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status addVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedaddVip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::VipMeta,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_delVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_delVip() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Vip, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Vip, ::lb::czkatran::Bool>* streamer) {
                       return this->StreameddelVip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_delVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status delVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddelVip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Vip,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getAllVips : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getAllVips() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Empty, ::lb::czkatran::Vips>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Empty, ::lb::czkatran::Vips>* streamer) {
                       return this->StreamedgetAllVips(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getAllVips() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getAllVips(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Vips* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetAllVips(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Empty,::lb::czkatran::Vips>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modifyVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modifyVip() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::VipMeta, ::lb::czkatran::Bool>* streamer) {
                       return this->StreamedmodifyVip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modifyVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modifyVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::VipMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodifyVip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::VipMeta,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modifyReal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modifyReal() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::RealMeta, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::RealMeta, ::lb::czkatran::Bool>* streamer) {
                       return this->StreamedmodifyReal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modifyReal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modifyReal(::grpc::ServerContext* /*context*/, const ::lb::czkatran::RealMeta* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodifyReal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::RealMeta,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getVipFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getVipFlags() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Vip, ::lb::czkatran::Flags>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Vip, ::lb::czkatran::Flags>* streamer) {
                       return this->StreamedgetVipFlags(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getVipFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getVipFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetVipFlags(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Vip,::lb::czkatran::Flags>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRealFlags : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRealFlags() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Real, ::lb::czkatran::Flags>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Real, ::lb::czkatran::Flags>* streamer) {
                       return this->StreamedgetRealFlags(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRealFlags() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRealFlags(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Real* /*request*/, ::lb::czkatran::Flags* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRealFlags(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Real,::lb::czkatran::Flags>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_addRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_addRealForVip() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::realForVip, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::realForVip, ::lb::czkatran::Bool>* streamer) {
                       return this->StreamedaddRealForVip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_addRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status addRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedaddRealForVip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::realForVip,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_delRealForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_delRealForVip() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::realForVip, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::realForVip, ::lb::czkatran::Bool>* streamer) {
                       return this->StreameddelRealForVip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_delRealForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status delRealForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::realForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddelRealForVip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::realForVip,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modifyRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modifyRealsForVip() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::ModifiedRealForVip, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::ModifiedRealForVip, ::lb::czkatran::Bool>* streamer) {
                       return this->StreamedmodifyRealsForVip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modifyRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modifyRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedRealForVip* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodifyRealsForVip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::ModifiedRealForVip,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRealsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRealsForVip() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Vip, ::lb::czkatran::Reals>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Vip, ::lb::czkatran::Reals>* streamer) {
                       return this->StreamedgetRealsForVip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRealsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRealsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Reals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRealsForVip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Vip,::lb::czkatran::Reals>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modifyQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modifyQuicRealsMapping() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::ModifiedQuicReals, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::ModifiedQuicReals, ::lb::czkatran::Bool>* streamer) {
                       return this->StreamedmodifyQuicRealsMapping(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modifyQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modifyQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::ModifiedQuicReals* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodifyQuicRealsMapping(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::ModifiedQuicReals,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getQuicRealsMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getQuicRealsMapping() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Empty, ::lb::czkatran::QuicReals>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Empty, ::lb::czkatran::QuicReals>* streamer) {
                       return this->StreamedgetQuicRealsMapping(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getQuicRealsMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getQuicRealsMapping(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::QuicReals* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetQuicRealsMapping(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Empty,::lb::czkatran::QuicReals>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getStatsForVip : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getStatsForVip() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Vip, ::lb::czkatran::Stats>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Vip, ::lb::czkatran::Stats>* streamer) {
                       return this->StreamedgetStatsForVip(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getStatsForVip() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getStatsForVip(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Vip* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetStatsForVip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Vip,::lb::czkatran::Stats>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getLruStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getLruStats() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Empty, ::lb::czkatran::Stats>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Empty, ::lb::czkatran::Stats>* streamer) {
                       return this->StreamedgetLruStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getLruStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getLruStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetLruStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Empty,::lb::czkatran::Stats>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getLruMissStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getLruMissStats() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Empty, ::lb::czkatran::Stats>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Empty, ::lb::czkatran::Stats>* streamer) {
                       return this->StreamedgetLruMissStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getLruMissStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getLruMissStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetLruMissStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Empty,::lb::czkatran::Stats>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getLruFailbackStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getLruFailbackStats() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Empty, ::lb::czkatran::Stats>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Empty, ::lb::czkatran::Stats>* streamer) {
                       return this->StreamedgetLruFailbackStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getLruFailbackStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getLruFailbackStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetLruFailbackStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Empty,::lb::czkatran::Stats>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getIcmpTooBigStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getIcmpTooBigStats() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Empty, ::lb::czkatran::Stats>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Empty, ::lb::czkatran::Stats>* streamer) {
                       return this->StreamedgetIcmpTooBigStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getIcmpTooBigStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getIcmpTooBigStats(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::Stats* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetIcmpTooBigStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Empty,::lb::czkatran::Stats>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_addHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_addHealthcheckerDst() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Healthcheck, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Healthcheck, ::lb::czkatran::Bool>* streamer) {
                       return this->StreamedaddHealthcheckerDst(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_addHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status addHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Healthcheck* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedaddHealthcheckerDst(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Healthcheck,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_delHealthcheckerDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_delHealthcheckerDst() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Somark, ::lb::czkatran::Bool>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Somark, ::lb::czkatran::Bool>* streamer) {
                       return this->StreameddelHealthcheckerDst(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_delHealthcheckerDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status delHealthcheckerDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Somark* /*request*/, ::lb::czkatran::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddelHealthcheckerDst(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Somark,::lb::czkatran::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getHealthcheckersDst : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getHealthcheckersDst() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::lb::czkatran::Empty, ::lb::czkatran::hcMap>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::lb::czkatran::Empty, ::lb::czkatran::hcMap>* streamer) {
                       return this->StreamedgetHealthcheckersDst(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getHealthcheckersDst() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getHealthcheckersDst(::grpc::ServerContext* /*context*/, const ::lb::czkatran::Empty* /*request*/, ::lb::czkatran::hcMap* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetHealthcheckersDst(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::lb::czkatran::Empty,::lb::czkatran::hcMap>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_changeMac<WithStreamedUnaryMethod_getMac<WithStreamedUnaryMethod_addVip<WithStreamedUnaryMethod_delVip<WithStreamedUnaryMethod_getAllVips<WithStreamedUnaryMethod_modifyVip<WithStreamedUnaryMethod_modifyReal<WithStreamedUnaryMethod_getVipFlags<WithStreamedUnaryMethod_getRealFlags<WithStreamedUnaryMethod_addRealForVip<WithStreamedUnaryMethod_delRealForVip<WithStreamedUnaryMethod_modifyRealsForVip<WithStreamedUnaryMethod_getRealsForVip<WithStreamedUnaryMethod_modifyQuicRealsMapping<WithStreamedUnaryMethod_getQuicRealsMapping<WithStreamedUnaryMethod_getStatsForVip<WithStreamedUnaryMethod_getLruStats<WithStreamedUnaryMethod_getLruMissStats<WithStreamedUnaryMethod_getLruFailbackStats<WithStreamedUnaryMethod_getIcmpTooBigStats<WithStreamedUnaryMethod_addHealthcheckerDst<WithStreamedUnaryMethod_delHealthcheckerDst<WithStreamedUnaryMethod_getHealthcheckersDst<Service > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_changeMac<WithStreamedUnaryMethod_getMac<WithStreamedUnaryMethod_addVip<WithStreamedUnaryMethod_delVip<WithStreamedUnaryMethod_getAllVips<WithStreamedUnaryMethod_modifyVip<WithStreamedUnaryMethod_modifyReal<WithStreamedUnaryMethod_getVipFlags<WithStreamedUnaryMethod_getRealFlags<WithStreamedUnaryMethod_addRealForVip<WithStreamedUnaryMethod_delRealForVip<WithStreamedUnaryMethod_modifyRealsForVip<WithStreamedUnaryMethod_getRealsForVip<WithStreamedUnaryMethod_modifyQuicRealsMapping<WithStreamedUnaryMethod_getQuicRealsMapping<WithStreamedUnaryMethod_getStatsForVip<WithStreamedUnaryMethod_getLruStats<WithStreamedUnaryMethod_getLruMissStats<WithStreamedUnaryMethod_getLruFailbackStats<WithStreamedUnaryMethod_getIcmpTooBigStats<WithStreamedUnaryMethod_addHealthcheckerDst<WithStreamedUnaryMethod_delHealthcheckerDst<WithStreamedUnaryMethod_getHealthcheckersDst<Service > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace czkatran
}  // namespace lb


#endif  // GRPC_czkatran_2eproto__INCLUDED
