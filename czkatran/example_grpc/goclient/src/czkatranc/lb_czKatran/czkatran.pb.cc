// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: czkatran.proto

#include "czkatran.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace lb {
namespace czkatran {
PROTOBUF_CONSTEXPR Empty::Empty(
    ::_pbi::ConstantInitialized) {}
struct EmptyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyDefaultTypeInternal() {}
  union {
    Empty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyDefaultTypeInternal _Empty_default_instance_;
PROTOBUF_CONSTEXPR Bool::Bool(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BoolDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolDefaultTypeInternal() {}
  union {
    Bool _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolDefaultTypeInternal _Bool_default_instance_;
PROTOBUF_CONSTEXPR Vip::Vip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_.protocol_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VipDefaultTypeInternal() {}
  union {
    Vip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VipDefaultTypeInternal _Vip_default_instance_;
PROTOBUF_CONSTEXPR VipMeta::VipMeta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vip_)*/nullptr
  , /*decltype(_impl_.flags_)*/int64_t{0}
  , /*decltype(_impl_.setflags_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VipMetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VipMetaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VipMetaDefaultTypeInternal() {}
  union {
    VipMeta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VipMetaDefaultTypeInternal _VipMeta_default_instance_;
PROTOBUF_CONSTEXPR RealMeta::RealMeta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flags_)*/0
  , /*decltype(_impl_.setflags_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RealMetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RealMetaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RealMetaDefaultTypeInternal() {}
  union {
    RealMeta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RealMetaDefaultTypeInternal _RealMeta_default_instance_;
PROTOBUF_CONSTEXPR Real::Real(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.weight_)*/0
  , /*decltype(_impl_.flags_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RealDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RealDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RealDefaultTypeInternal() {}
  union {
    Real _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RealDefaultTypeInternal _Real_default_instance_;
PROTOBUF_CONSTEXPR QuicReal::QuicReal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuicRealDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuicRealDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuicRealDefaultTypeInternal() {}
  union {
    QuicReal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuicRealDefaultTypeInternal _QuicReal_default_instance_;
PROTOBUF_CONSTEXPR Mac::Mac(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MacDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MacDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MacDefaultTypeInternal() {}
  union {
    Mac _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MacDefaultTypeInternal _Mac_default_instance_;
PROTOBUF_CONSTEXPR Stats::Stats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.v1_)*/uint64_t{0u}
  , /*decltype(_impl_.v2_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsDefaultTypeInternal() {}
  union {
    Stats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsDefaultTypeInternal _Stats_default_instance_;
PROTOBUF_CONSTEXPR Healthcheck::Healthcheck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.somark_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HealthcheckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HealthcheckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HealthcheckDefaultTypeInternal() {}
  union {
    Healthcheck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HealthcheckDefaultTypeInternal _Healthcheck_default_instance_;
PROTOBUF_CONSTEXPR hcMap_HealthchecksEntry_DoNotUse::hcMap_HealthchecksEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct hcMap_HealthchecksEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR hcMap_HealthchecksEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~hcMap_HealthchecksEntry_DoNotUseDefaultTypeInternal() {}
  union {
    hcMap_HealthchecksEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 hcMap_HealthchecksEntry_DoNotUseDefaultTypeInternal _hcMap_HealthchecksEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR hcMap::hcMap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.healthchecks_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct hcMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR hcMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~hcMapDefaultTypeInternal() {}
  union {
    hcMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 hcMapDefaultTypeInternal _hcMap_default_instance_;
PROTOBUF_CONSTEXPR Reals::Reals(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.reals_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RealsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RealsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RealsDefaultTypeInternal() {}
  union {
    Reals _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RealsDefaultTypeInternal _Reals_default_instance_;
PROTOBUF_CONSTEXPR Vips::Vips(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vips_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VipsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VipsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VipsDefaultTypeInternal() {}
  union {
    Vips _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VipsDefaultTypeInternal _Vips_default_instance_;
PROTOBUF_CONSTEXPR QuicReals::QuicReals(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.qreals_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuicRealsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuicRealsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuicRealsDefaultTypeInternal() {}
  union {
    QuicReals _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuicRealsDefaultTypeInternal _QuicReals_default_instance_;
PROTOBUF_CONSTEXPR ModifiedRealForVip::ModifiedRealForVip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.real_)*/nullptr
  , /*decltype(_impl_.vip_)*/nullptr
  , /*decltype(_impl_.action_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModifiedRealForVipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifiedRealForVipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifiedRealForVipDefaultTypeInternal() {}
  union {
    ModifiedRealForVip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifiedRealForVipDefaultTypeInternal _ModifiedRealForVip_default_instance_;
PROTOBUF_CONSTEXPR ModifiedQuicReals::ModifiedQuicReals(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.qreals_)*/nullptr
  , /*decltype(_impl_.action_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModifiedQuicRealsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifiedQuicRealsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifiedQuicRealsDefaultTypeInternal() {}
  union {
    ModifiedQuicReals _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifiedQuicRealsDefaultTypeInternal _ModifiedQuicReals_default_instance_;
PROTOBUF_CONSTEXPR realForVip::realForVip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.real_)*/nullptr
  , /*decltype(_impl_.vip_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct realForVipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR realForVipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~realForVipDefaultTypeInternal() {}
  union {
    realForVip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 realForVipDefaultTypeInternal _realForVip_default_instance_;
PROTOBUF_CONSTEXPR Flags::Flags(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flags_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlagsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlagsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlagsDefaultTypeInternal() {}
  union {
    Flags _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlagsDefaultTypeInternal _Flags_default_instance_;
PROTOBUF_CONSTEXPR Somark::Somark(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.somark_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SomarkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SomarkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SomarkDefaultTypeInternal() {}
  union {
    Somark _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SomarkDefaultTypeInternal _Somark_default_instance_;
}  // namespace czkatran
}  // namespace lb
static ::_pb::Metadata file_level_metadata_czkatran_2eproto[20];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_czkatran_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_czkatran_2eproto = nullptr;

const uint32_t TableStruct_czkatran_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Empty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Bool, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Bool, _impl_.success_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Vip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Vip, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Vip, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Vip, _impl_.protocol_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::VipMeta, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::VipMeta, _impl_.vip_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::VipMeta, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::VipMeta, _impl_.setflags_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::RealMeta, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::RealMeta, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::RealMeta, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::RealMeta, _impl_.setflags_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Real, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Real, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Real, _impl_.weight_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Real, _impl_.flags_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::QuicReal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::QuicReal, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::QuicReal, _impl_.id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Mac, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Mac, _impl_.mac_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Stats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Stats, _impl_.v1_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Stats, _impl_.v2_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Healthcheck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Healthcheck, _impl_.somark_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Healthcheck, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::hcMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::hcMap, _impl_.healthchecks_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Reals, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Reals, _impl_.reals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Vips, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Vips, _impl_.vips_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::QuicReals, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::QuicReals, _impl_.qreals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::ModifiedRealForVip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::ModifiedRealForVip, _impl_.action_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::ModifiedRealForVip, _impl_.real_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::ModifiedRealForVip, _impl_.vip_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::ModifiedQuicReals, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::ModifiedQuicReals, _impl_.action_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::ModifiedQuicReals, _impl_.qreals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::realForVip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::realForVip, _impl_.real_),
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::realForVip, _impl_.vip_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Flags, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Flags, _impl_.flags_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Somark, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lb::czkatran::Somark, _impl_.somark_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::lb::czkatran::Empty)},
  { 6, -1, -1, sizeof(::lb::czkatran::Bool)},
  { 13, -1, -1, sizeof(::lb::czkatran::Vip)},
  { 22, -1, -1, sizeof(::lb::czkatran::VipMeta)},
  { 31, -1, -1, sizeof(::lb::czkatran::RealMeta)},
  { 40, -1, -1, sizeof(::lb::czkatran::Real)},
  { 49, -1, -1, sizeof(::lb::czkatran::QuicReal)},
  { 57, -1, -1, sizeof(::lb::czkatran::Mac)},
  { 64, -1, -1, sizeof(::lb::czkatran::Stats)},
  { 72, -1, -1, sizeof(::lb::czkatran::Healthcheck)},
  { 80, 88, -1, sizeof(::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse)},
  { 90, -1, -1, sizeof(::lb::czkatran::hcMap)},
  { 97, -1, -1, sizeof(::lb::czkatran::Reals)},
  { 104, -1, -1, sizeof(::lb::czkatran::Vips)},
  { 111, -1, -1, sizeof(::lb::czkatran::QuicReals)},
  { 118, -1, -1, sizeof(::lb::czkatran::ModifiedRealForVip)},
  { 127, -1, -1, sizeof(::lb::czkatran::ModifiedQuicReals)},
  { 135, -1, -1, sizeof(::lb::czkatran::realForVip)},
  { 143, -1, -1, sizeof(::lb::czkatran::Flags)},
  { 150, -1, -1, sizeof(::lb::czkatran::Somark)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::lb::czkatran::_Empty_default_instance_._instance,
  &::lb::czkatran::_Bool_default_instance_._instance,
  &::lb::czkatran::_Vip_default_instance_._instance,
  &::lb::czkatran::_VipMeta_default_instance_._instance,
  &::lb::czkatran::_RealMeta_default_instance_._instance,
  &::lb::czkatran::_Real_default_instance_._instance,
  &::lb::czkatran::_QuicReal_default_instance_._instance,
  &::lb::czkatran::_Mac_default_instance_._instance,
  &::lb::czkatran::_Stats_default_instance_._instance,
  &::lb::czkatran::_Healthcheck_default_instance_._instance,
  &::lb::czkatran::_hcMap_HealthchecksEntry_DoNotUse_default_instance_._instance,
  &::lb::czkatran::_hcMap_default_instance_._instance,
  &::lb::czkatran::_Reals_default_instance_._instance,
  &::lb::czkatran::_Vips_default_instance_._instance,
  &::lb::czkatran::_QuicReals_default_instance_._instance,
  &::lb::czkatran::_ModifiedRealForVip_default_instance_._instance,
  &::lb::czkatran::_ModifiedQuicReals_default_instance_._instance,
  &::lb::czkatran::_realForVip_default_instance_._instance,
  &::lb::czkatran::_Flags_default_instance_._instance,
  &::lb::czkatran::_Somark_default_instance_._instance,
};

const char descriptor_table_protodef_czkatran_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016czkatran.proto\022\013lb.czkatran\"\007\n\005Empty\"\027"
  "\n\004Bool\022\017\n\007success\030\001 \001(\010\"6\n\003Vip\022\017\n\007addres"
  "s\030\001 \001(\t\022\014\n\004port\030\002 \001(\005\022\020\n\010protocol\030\003 \001(\005\""
  "I\n\007VipMeta\022\035\n\003vip\030\001 \001(\0132\020.lb.czkatran.Vi"
  "p\022\r\n\005flags\030\002 \001(\003\022\020\n\010setflags\030\003 \001(\010\"<\n\010Re"
  "alMeta\022\017\n\007address\030\001 \001(\t\022\r\n\005flags\030\002 \001(\005\022\020"
  "\n\010setflags\030\003 \001(\010\"6\n\004Real\022\017\n\007address\030\001 \001("
  "\t\022\016\n\006weight\030\002 \001(\005\022\r\n\005flags\030\003 \001(\005\"\'\n\010Quic"
  "Real\022\017\n\007address\030\001 \001(\t\022\n\n\002id\030\002 \001(\005\"\022\n\003Mac"
  "\022\013\n\003mac\030\001 \001(\t\"\037\n\005Stats\022\n\n\002v1\030\001 \001(\004\022\n\n\002v2"
  "\030\002 \001(\004\".\n\013Healthcheck\022\016\n\006somark\030\001 \001(\r\022\017\n"
  "\007address\030\002 \001(\t\"x\n\005hcMap\022:\n\014healthchecks\030"
  "\001 \003(\0132$.lb.czkatran.hcMap.HealthchecksEn"
  "try\0323\n\021HealthchecksEntry\022\013\n\003key\030\001 \001(\005\022\r\n"
  "\005value\030\002 \001(\t:\0028\001\")\n\005Reals\022 \n\005reals\030\001 \003(\013"
  "2\021.lb.czkatran.Real\"&\n\004Vips\022\036\n\004vips\030\001 \003("
  "\0132\020.lb.czkatran.Vip\"2\n\tQuicReals\022%\n\006qrea"
  "ls\030\001 \003(\0132\025.lb.czkatran.QuicReal\"z\n\022Modif"
  "iedRealForVip\022#\n\006action\030\001 \001(\0162\023.lb.czkat"
  "ran.Action\022 \n\004real\030\002 \001(\0132\022.lb.czkatran.R"
  "eals\022\035\n\003vip\030\003 \001(\0132\020.lb.czkatran.Vip\"`\n\021M"
  "odifiedQuicReals\022#\n\006action\030\001 \001(\0162\023.lb.cz"
  "katran.Action\022&\n\006qreals\030\002 \001(\0132\026.lb.czkat"
  "ran.QuicReals\"L\n\nrealForVip\022\037\n\004real\030\001 \001("
  "\0132\021.lb.czkatran.Real\022\035\n\003vip\030\002 \001(\0132\020.lb.c"
  "zkatran.Vip\"\026\n\005Flags\022\r\n\005flags\030\001 \001(\004\"\030\n\006S"
  "omark\022\016\n\006somark\030\001 \001(\r*\032\n\006Action\022\007\n\003ADD\020\000"
  "\022\007\n\003DEl\020\0012\331\n\n\017czKatranService\0220\n\tchangeM"
  "ac\022\020.lb.czkatran.Mac\032\021.lb.czkatran.Bool\022"
  ".\n\006getMac\022\022.lb.czkatran.Empty\032\020.lb.czkat"
  "ran.Mac\0221\n\006addVip\022\024.lb.czkatran.VipMeta\032"
  "\021.lb.czkatran.Bool\022-\n\006delVip\022\020.lb.czkatr"
  "an.Vip\032\021.lb.czkatran.Bool\0223\n\ngetAllVips\022"
  "\022.lb.czkatran.Empty\032\021.lb.czkatran.Vips\0224"
  "\n\tmodifyVip\022\024.lb.czkatran.VipMeta\032\021.lb.c"
  "zkatran.Bool\0226\n\nmodifyReal\022\025.lb.czkatran"
  ".RealMeta\032\021.lb.czkatran.Bool\0223\n\013getVipFl"
  "ags\022\020.lb.czkatran.Vip\032\022.lb.czkatran.Flag"
  "s\0225\n\014getRealFlags\022\021.lb.czkatran.Real\032\022.l"
  "b.czkatran.Flags\022;\n\raddRealForVip\022\027.lb.c"
  "zkatran.realForVip\032\021.lb.czkatran.Bool\022;\n"
  "\rdelRealForVip\022\027.lb.czkatran.realForVip\032"
  "\021.lb.czkatran.Bool\022G\n\021modifyRealsForVip\022"
  "\037.lb.czkatran.ModifiedRealForVip\032\021.lb.cz"
  "katran.Bool\0226\n\016getRealsForVip\022\020.lb.czkat"
  "ran.Vip\032\022.lb.czkatran.Reals\022K\n\026modifyQui"
  "cRealsMapping\022\036.lb.czkatran.ModifiedQuic"
  "Reals\032\021.lb.czkatran.Bool\022A\n\023getQuicReals"
  "Mapping\022\022.lb.czkatran.Empty\032\026.lb.czkatra"
  "n.QuicReals\0226\n\016getStatsForVip\022\020.lb.czkat"
  "ran.Vip\032\022.lb.czkatran.Stats\0225\n\013getLruSta"
  "ts\022\022.lb.czkatran.Empty\032\022.lb.czkatran.Sta"
  "ts\0229\n\017getLruMissStats\022\022.lb.czkatran.Empt"
  "y\032\022.lb.czkatran.Stats\022=\n\023getLruFailbackS"
  "tats\022\022.lb.czkatran.Empty\032\022.lb.czkatran.S"
  "tats\022<\n\022getIcmpTooBigStats\022\022.lb.czkatran"
  ".Empty\032\022.lb.czkatran.Stats\022B\n\023addHealthc"
  "heckerDst\022\030.lb.czkatran.Healthcheck\032\021.lb"
  ".czkatran.Bool\022=\n\023delHealthcheckerDst\022\023."
  "lb.czkatran.Somark\032\021.lb.czkatran.Bool\022>\n"
  "\024getHealthcheckersDst\022\022.lb.czkatran.Empt"
  "y\032\022.lb.czkatran.hcMapB\013Z\t./;protosb\006prot"
  "o3"
  ;
static ::_pbi::once_flag descriptor_table_czkatran_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_czkatran_2eproto = {
    false, false, 2482, descriptor_table_protodef_czkatran_2eproto,
    "czkatran.proto",
    &descriptor_table_czkatran_2eproto_once, nullptr, 0, 20,
    schemas, file_default_instances, TableStruct_czkatran_2eproto::offsets,
    file_level_metadata_czkatran_2eproto, file_level_enum_descriptors_czkatran_2eproto,
    file_level_service_descriptors_czkatran_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_czkatran_2eproto_getter() {
  return &descriptor_table_czkatran_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_czkatran_2eproto(&descriptor_table_czkatran_2eproto);
namespace lb {
namespace czkatran {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_czkatran_2eproto);
  return file_level_enum_descriptors_czkatran_2eproto[0];
}
bool Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Empty::_Internal {
 public:
};

Empty::Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Empty)
}
Empty::Empty(const Empty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Empty* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Empty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Empty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Empty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Empty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[0]);
}

// ===================================================================

class Bool::_Internal {
 public:
};

Bool::Bool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Bool)
}
Bool::Bool(const Bool& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Bool* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Bool)
}

inline void Bool::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Bool::~Bool() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Bool)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Bool::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Bool::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Bool::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Bool)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.success_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bool::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Bool::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Bool)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Bool)
  return target;
}

size_t Bool::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Bool)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bool::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Bool::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bool::GetClassData() const { return &_class_data_; }


void Bool::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Bool*>(&to_msg);
  auto& from = static_cast<const Bool&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Bool)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bool::CopyFrom(const Bool& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Bool)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bool::IsInitialized() const {
  return true;
}

void Bool::InternalSwap(Bool* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Bool::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[1]);
}

// ===================================================================

class Vip::_Internal {
 public:
};

Vip::Vip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Vip)
}
Vip::Vip(const Vip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.protocol_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.port_, &from._impl_.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.protocol_) -
    reinterpret_cast<char*>(&_impl_.port_)) + sizeof(_impl_.protocol_));
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Vip)
}

inline void Vip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.port_){0}
    , decltype(_impl_.protocol_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Vip::~Vip() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Vip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
}

void Vip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vip::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Vip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  ::memset(&_impl_.port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.protocol_) -
      reinterpret_cast<char*>(&_impl_.port_)) + sizeof(_impl_.protocol_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "lb.czkatran.Vip.address"));
        } else
          goto handle_unusual;
        continue;
      // int32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 protocol = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Vip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1;
  if (!this->_internal_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "lb.czkatran.Vip.address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_address(), target);
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_port(), target);
  }

  // int32 protocol = 3;
  if (this->_internal_protocol() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_protocol(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Vip)
  return target;
}

size_t Vip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Vip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  // int32 protocol = 3;
  if (this->_internal_protocol() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_protocol());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vip::GetClassData() const { return &_class_data_; }


void Vip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vip*>(&to_msg);
  auto& from = static_cast<const Vip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Vip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  if (from._internal_protocol() != 0) {
    _this->_internal_set_protocol(from._internal_protocol());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vip::CopyFrom(const Vip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Vip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vip::IsInitialized() const {
  return true;
}

void Vip::InternalSwap(Vip* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vip, _impl_.protocol_)
      + sizeof(Vip::_impl_.protocol_)
      - PROTOBUF_FIELD_OFFSET(Vip, _impl_.port_)>(
          reinterpret_cast<char*>(&_impl_.port_),
          reinterpret_cast<char*>(&other->_impl_.port_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[2]);
}

// ===================================================================

class VipMeta::_Internal {
 public:
  static const ::lb::czkatran::Vip& vip(const VipMeta* msg);
};

const ::lb::czkatran::Vip&
VipMeta::_Internal::vip(const VipMeta* msg) {
  return *msg->_impl_.vip_;
}
VipMeta::VipMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.VipMeta)
}
VipMeta::VipMeta(const VipMeta& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VipMeta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vip_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.setflags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_vip()) {
    _this->_impl_.vip_ = new ::lb::czkatran::Vip(*from._impl_.vip_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.setflags_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.setflags_));
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.VipMeta)
}

inline void VipMeta::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vip_){nullptr}
    , decltype(_impl_.flags_){int64_t{0}}
    , decltype(_impl_.setflags_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VipMeta::~VipMeta() {
  // @@protoc_insertion_point(destructor:lb.czkatran.VipMeta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VipMeta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.vip_;
}

void VipMeta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VipMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.VipMeta)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.vip_ != nullptr) {
    delete _impl_.vip_;
  }
  _impl_.vip_ = nullptr;
  ::memset(&_impl_.flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.setflags_) -
      reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.setflags_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VipMeta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .lb.czkatran.Vip vip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_vip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool setflags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.setflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VipMeta::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.VipMeta)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .lb.czkatran.Vip vip = 1;
  if (this->_internal_has_vip()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::vip(this),
        _Internal::vip(this).GetCachedSize(), target, stream);
  }

  // int64 flags = 2;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_flags(), target);
  }

  // bool setflags = 3;
  if (this->_internal_setflags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_setflags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.VipMeta)
  return target;
}

size_t VipMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.VipMeta)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .lb.czkatran.Vip vip = 1;
  if (this->_internal_has_vip()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vip_);
  }

  // int64 flags = 2;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_flags());
  }

  // bool setflags = 3;
  if (this->_internal_setflags() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VipMeta::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VipMeta::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VipMeta::GetClassData() const { return &_class_data_; }


void VipMeta::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VipMeta*>(&to_msg);
  auto& from = static_cast<const VipMeta&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.VipMeta)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_vip()) {
    _this->_internal_mutable_vip()->::lb::czkatran::Vip::MergeFrom(
        from._internal_vip());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  if (from._internal_setflags() != 0) {
    _this->_internal_set_setflags(from._internal_setflags());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VipMeta::CopyFrom(const VipMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.VipMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VipMeta::IsInitialized() const {
  return true;
}

void VipMeta::InternalSwap(VipMeta* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VipMeta, _impl_.setflags_)
      + sizeof(VipMeta::_impl_.setflags_)
      - PROTOBUF_FIELD_OFFSET(VipMeta, _impl_.vip_)>(
          reinterpret_cast<char*>(&_impl_.vip_),
          reinterpret_cast<char*>(&other->_impl_.vip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VipMeta::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[3]);
}

// ===================================================================

class RealMeta::_Internal {
 public:
};

RealMeta::RealMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.RealMeta)
}
RealMeta::RealMeta(const RealMeta& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RealMeta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.setflags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.setflags_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.setflags_));
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.RealMeta)
}

inline void RealMeta::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.flags_){0}
    , decltype(_impl_.setflags_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RealMeta::~RealMeta() {
  // @@protoc_insertion_point(destructor:lb.czkatran.RealMeta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RealMeta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
}

void RealMeta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RealMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.RealMeta)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  ::memset(&_impl_.flags_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.setflags_) -
      reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.setflags_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RealMeta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "lb.czkatran.RealMeta.address"));
        } else
          goto handle_unusual;
        continue;
      // int32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool setflags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.setflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RealMeta::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.RealMeta)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1;
  if (!this->_internal_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "lb.czkatran.RealMeta.address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_address(), target);
  }

  // int32 flags = 2;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_flags(), target);
  }

  // bool setflags = 3;
  if (this->_internal_setflags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_setflags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.RealMeta)
  return target;
}

size_t RealMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.RealMeta)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  // int32 flags = 2;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
  }

  // bool setflags = 3;
  if (this->_internal_setflags() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RealMeta::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RealMeta::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RealMeta::GetClassData() const { return &_class_data_; }


void RealMeta::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RealMeta*>(&to_msg);
  auto& from = static_cast<const RealMeta&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.RealMeta)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  if (from._internal_setflags() != 0) {
    _this->_internal_set_setflags(from._internal_setflags());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RealMeta::CopyFrom(const RealMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.RealMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RealMeta::IsInitialized() const {
  return true;
}

void RealMeta::InternalSwap(RealMeta* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RealMeta, _impl_.setflags_)
      + sizeof(RealMeta::_impl_.setflags_)
      - PROTOBUF_FIELD_OFFSET(RealMeta, _impl_.flags_)>(
          reinterpret_cast<char*>(&_impl_.flags_),
          reinterpret_cast<char*>(&other->_impl_.flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RealMeta::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[4]);
}

// ===================================================================

class Real::_Internal {
 public:
};

Real::Real(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Real)
}
Real::Real(const Real& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Real* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.weight_){}
    , decltype(_impl_.flags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.weight_, &from._impl_.weight_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.weight_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Real)
}

inline void Real::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.weight_){0}
    , decltype(_impl_.flags_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Real::~Real() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Real)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Real::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
}

void Real::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Real::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Real)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  ::memset(&_impl_.weight_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.flags_) -
      reinterpret_cast<char*>(&_impl_.weight_)) + sizeof(_impl_.flags_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Real::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "lb.czkatran.Real.address"));
        } else
          goto handle_unusual;
        continue;
      // int32 weight = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Real::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Real)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1;
  if (!this->_internal_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "lb.czkatran.Real.address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_address(), target);
  }

  // int32 weight = 2;
  if (this->_internal_weight() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_weight(), target);
  }

  // int32 flags = 3;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Real)
  return target;
}

size_t Real::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Real)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  // int32 weight = 2;
  if (this->_internal_weight() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weight());
  }

  // int32 flags = 3;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Real::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Real::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Real::GetClassData() const { return &_class_data_; }


void Real::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Real*>(&to_msg);
  auto& from = static_cast<const Real&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Real)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (from._internal_weight() != 0) {
    _this->_internal_set_weight(from._internal_weight());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Real::CopyFrom(const Real& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Real)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Real::IsInitialized() const {
  return true;
}

void Real::InternalSwap(Real* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Real, _impl_.flags_)
      + sizeof(Real::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Real, _impl_.weight_)>(
          reinterpret_cast<char*>(&_impl_.weight_),
          reinterpret_cast<char*>(&other->_impl_.weight_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Real::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[5]);
}

// ===================================================================

class QuicReal::_Internal {
 public:
};

QuicReal::QuicReal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.QuicReal)
}
QuicReal::QuicReal(const QuicReal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QuicReal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.QuicReal)
}

inline void QuicReal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QuicReal::~QuicReal() {
  // @@protoc_insertion_point(destructor:lb.czkatran.QuicReal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuicReal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
}

void QuicReal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuicReal::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.QuicReal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  _impl_.id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QuicReal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "lb.czkatran.QuicReal.address"));
        } else
          goto handle_unusual;
        continue;
      // int32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuicReal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.QuicReal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string address = 1;
  if (!this->_internal_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "lb.czkatran.QuicReal.address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_address(), target);
  }

  // int32 id = 2;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.QuicReal)
  return target;
}

size_t QuicReal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.QuicReal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 1;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  // int32 id = 2;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QuicReal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QuicReal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QuicReal::GetClassData() const { return &_class_data_; }


void QuicReal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QuicReal*>(&to_msg);
  auto& from = static_cast<const QuicReal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.QuicReal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QuicReal::CopyFrom(const QuicReal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.QuicReal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuicReal::IsInitialized() const {
  return true;
}

void QuicReal::InternalSwap(QuicReal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata QuicReal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[6]);
}

// ===================================================================

class Mac::_Internal {
 public:
};

Mac::Mac(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Mac)
}
Mac::Mac(const Mac& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Mac* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mac_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac().empty()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Mac)
}

inline void Mac::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mac_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Mac::~Mac() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Mac)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Mac::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mac_.Destroy();
}

void Mac::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Mac::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Mac)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mac_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Mac::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string mac = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "lb.czkatran.Mac.mac"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Mac::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Mac)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string mac = 1;
  if (!this->_internal_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "lb.czkatran.Mac.mac");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mac(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Mac)
  return target;
}

size_t Mac::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Mac)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mac = 1;
  if (!this->_internal_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Mac::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Mac::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Mac::GetClassData() const { return &_class_data_; }


void Mac::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Mac*>(&to_msg);
  auto& from = static_cast<const Mac&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Mac)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mac().empty()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Mac::CopyFrom(const Mac& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Mac)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mac::IsInitialized() const {
  return true;
}

void Mac::InternalSwap(Mac* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Mac::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[7]);
}

// ===================================================================

class Stats::_Internal {
 public:
};

Stats::Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Stats)
}
Stats::Stats(const Stats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Stats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.v1_){}
    , decltype(_impl_.v2_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.v1_, &from._impl_.v1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.v2_) -
    reinterpret_cast<char*>(&_impl_.v1_)) + sizeof(_impl_.v2_));
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Stats)
}

inline void Stats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.v1_){uint64_t{0u}}
    , decltype(_impl_.v2_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Stats::~Stats() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Stats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Stats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Stats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Stats::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Stats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.v1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.v2_) -
      reinterpret_cast<char*>(&_impl_.v1_)) + sizeof(_impl_.v2_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 v1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.v1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 v2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.v2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Stats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Stats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 v1 = 1;
  if (this->_internal_v1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_v1(), target);
  }

  // uint64 v2 = 2;
  if (this->_internal_v2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_v2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Stats)
  return target;
}

size_t Stats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Stats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 v1 = 1;
  if (this->_internal_v1() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v1());
  }

  // uint64 v2 = 2;
  if (this->_internal_v2() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v2());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Stats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stats::GetClassData() const { return &_class_data_; }


void Stats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Stats*>(&to_msg);
  auto& from = static_cast<const Stats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Stats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_v1() != 0) {
    _this->_internal_set_v1(from._internal_v1());
  }
  if (from._internal_v2() != 0) {
    _this->_internal_set_v2(from._internal_v2());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stats::CopyFrom(const Stats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Stats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stats::IsInitialized() const {
  return true;
}

void Stats::InternalSwap(Stats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Stats, _impl_.v2_)
      + sizeof(Stats::_impl_.v2_)
      - PROTOBUF_FIELD_OFFSET(Stats, _impl_.v1_)>(
          reinterpret_cast<char*>(&_impl_.v1_),
          reinterpret_cast<char*>(&other->_impl_.v1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Stats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[8]);
}

// ===================================================================

class Healthcheck::_Internal {
 public:
};

Healthcheck::Healthcheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Healthcheck)
}
Healthcheck::Healthcheck(const Healthcheck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Healthcheck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.somark_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.somark_ = from._impl_.somark_;
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Healthcheck)
}

inline void Healthcheck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){}
    , decltype(_impl_.somark_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Healthcheck::~Healthcheck() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Healthcheck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Healthcheck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
}

void Healthcheck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Healthcheck::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Healthcheck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  _impl_.somark_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Healthcheck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 somark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.somark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "lb.czkatran.Healthcheck.address"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Healthcheck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Healthcheck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 somark = 1;
  if (this->_internal_somark() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_somark(), target);
  }

  // string address = 2;
  if (!this->_internal_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "lb.czkatran.Healthcheck.address");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Healthcheck)
  return target;
}

size_t Healthcheck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Healthcheck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 2;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  // uint32 somark = 1;
  if (this->_internal_somark() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_somark());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Healthcheck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Healthcheck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Healthcheck::GetClassData() const { return &_class_data_; }


void Healthcheck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Healthcheck*>(&to_msg);
  auto& from = static_cast<const Healthcheck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Healthcheck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (from._internal_somark() != 0) {
    _this->_internal_set_somark(from._internal_somark());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Healthcheck::CopyFrom(const Healthcheck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Healthcheck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Healthcheck::IsInitialized() const {
  return true;
}

void Healthcheck::InternalSwap(Healthcheck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  swap(_impl_.somark_, other->_impl_.somark_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Healthcheck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[9]);
}

// ===================================================================

hcMap_HealthchecksEntry_DoNotUse::hcMap_HealthchecksEntry_DoNotUse() {}
hcMap_HealthchecksEntry_DoNotUse::hcMap_HealthchecksEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void hcMap_HealthchecksEntry_DoNotUse::MergeFrom(const hcMap_HealthchecksEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata hcMap_HealthchecksEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[10]);
}

// ===================================================================

class hcMap::_Internal {
 public:
};

hcMap::hcMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &hcMap::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.hcMap)
}
hcMap::hcMap(const hcMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  hcMap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.healthchecks_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.healthchecks_.MergeFrom(from._impl_.healthchecks_);
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.hcMap)
}

inline void hcMap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.healthchecks_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

hcMap::~hcMap() {
  // @@protoc_insertion_point(destructor:lb.czkatran.hcMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void hcMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.healthchecks_.Destruct();
  _impl_.healthchecks_.~MapField();
}

void hcMap::ArenaDtor(void* object) {
  hcMap* _this = reinterpret_cast< hcMap* >(object);
  _this->_impl_.healthchecks_.Destruct();
}
void hcMap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void hcMap::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.hcMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.healthchecks_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* hcMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int32, string> healthchecks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.healthchecks_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* hcMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.hcMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int32, string> healthchecks = 1;
  if (!this->_internal_healthchecks().empty()) {
    using MapType = ::_pb::Map<int32_t, std::string>;
    using WireHelper = hcMap_HealthchecksEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_healthchecks();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "lb.czkatran.hcMap.HealthchecksEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.hcMap)
  return target;
}

size_t hcMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.hcMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, string> healthchecks = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_healthchecks_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >::const_iterator
      it = this->_internal_healthchecks().begin();
      it != this->_internal_healthchecks().end(); ++it) {
    total_size += hcMap_HealthchecksEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData hcMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    hcMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*hcMap::GetClassData() const { return &_class_data_; }


void hcMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<hcMap*>(&to_msg);
  auto& from = static_cast<const hcMap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.hcMap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.healthchecks_.MergeFrom(from._impl_.healthchecks_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void hcMap::CopyFrom(const hcMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.hcMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool hcMap::IsInitialized() const {
  return true;
}

void hcMap::InternalSwap(hcMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.healthchecks_.InternalSwap(&other->_impl_.healthchecks_);
}

::PROTOBUF_NAMESPACE_ID::Metadata hcMap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[11]);
}

// ===================================================================

class Reals::_Internal {
 public:
};

Reals::Reals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Reals)
}
Reals::Reals(const Reals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Reals* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.reals_){from._impl_.reals_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Reals)
}

inline void Reals::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.reals_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Reals::~Reals() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Reals)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Reals::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reals_.~RepeatedPtrField();
}

void Reals::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Reals::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Reals)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Reals::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .lb.czkatran.Real reals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_reals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Reals::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Reals)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lb.czkatran.Real reals = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_reals_size()); i < n; i++) {
    const auto& repfield = this->_internal_reals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Reals)
  return target;
}

size_t Reals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Reals)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lb.czkatran.Real reals = 1;
  total_size += 1UL * this->_internal_reals_size();
  for (const auto& msg : this->_impl_.reals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Reals::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Reals::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Reals::GetClassData() const { return &_class_data_; }


void Reals::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Reals*>(&to_msg);
  auto& from = static_cast<const Reals&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Reals)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.reals_.MergeFrom(from._impl_.reals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Reals::CopyFrom(const Reals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Reals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reals::IsInitialized() const {
  return true;
}

void Reals::InternalSwap(Reals* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.reals_.InternalSwap(&other->_impl_.reals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Reals::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[12]);
}

// ===================================================================

class Vips::_Internal {
 public:
};

Vips::Vips(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Vips)
}
Vips::Vips(const Vips& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vips* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vips_){from._impl_.vips_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Vips)
}

inline void Vips::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vips_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Vips::~Vips() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Vips)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vips::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vips_.~RepeatedPtrField();
}

void Vips::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vips::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Vips)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vips_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vips::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .lb.czkatran.Vip vips = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vips::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Vips)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lb.czkatran.Vip vips = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vips_size()); i < n; i++) {
    const auto& repfield = this->_internal_vips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Vips)
  return target;
}

size_t Vips::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Vips)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lb.czkatran.Vip vips = 1;
  total_size += 1UL * this->_internal_vips_size();
  for (const auto& msg : this->_impl_.vips_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vips::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vips::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vips::GetClassData() const { return &_class_data_; }


void Vips::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vips*>(&to_msg);
  auto& from = static_cast<const Vips&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Vips)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vips_.MergeFrom(from._impl_.vips_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vips::CopyFrom(const Vips& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Vips)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vips::IsInitialized() const {
  return true;
}

void Vips::InternalSwap(Vips* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vips_.InternalSwap(&other->_impl_.vips_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Vips::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[13]);
}

// ===================================================================

class QuicReals::_Internal {
 public:
};

QuicReals::QuicReals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.QuicReals)
}
QuicReals::QuicReals(const QuicReals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QuicReals* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.qreals_){from._impl_.qreals_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.QuicReals)
}

inline void QuicReals::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.qreals_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

QuicReals::~QuicReals() {
  // @@protoc_insertion_point(destructor:lb.czkatran.QuicReals)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuicReals::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.qreals_.~RepeatedPtrField();
}

void QuicReals::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuicReals::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.QuicReals)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.qreals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QuicReals::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .lb.czkatran.QuicReal qreals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_qreals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuicReals::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.QuicReals)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lb.czkatran.QuicReal qreals = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_qreals_size()); i < n; i++) {
    const auto& repfield = this->_internal_qreals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.QuicReals)
  return target;
}

size_t QuicReals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.QuicReals)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lb.czkatran.QuicReal qreals = 1;
  total_size += 1UL * this->_internal_qreals_size();
  for (const auto& msg : this->_impl_.qreals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QuicReals::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QuicReals::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QuicReals::GetClassData() const { return &_class_data_; }


void QuicReals::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QuicReals*>(&to_msg);
  auto& from = static_cast<const QuicReals&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.QuicReals)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.qreals_.MergeFrom(from._impl_.qreals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QuicReals::CopyFrom(const QuicReals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.QuicReals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuicReals::IsInitialized() const {
  return true;
}

void QuicReals::InternalSwap(QuicReals* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.qreals_.InternalSwap(&other->_impl_.qreals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata QuicReals::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[14]);
}

// ===================================================================

class ModifiedRealForVip::_Internal {
 public:
  static const ::lb::czkatran::Reals& real(const ModifiedRealForVip* msg);
  static const ::lb::czkatran::Vip& vip(const ModifiedRealForVip* msg);
};

const ::lb::czkatran::Reals&
ModifiedRealForVip::_Internal::real(const ModifiedRealForVip* msg) {
  return *msg->_impl_.real_;
}
const ::lb::czkatran::Vip&
ModifiedRealForVip::_Internal::vip(const ModifiedRealForVip* msg) {
  return *msg->_impl_.vip_;
}
ModifiedRealForVip::ModifiedRealForVip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.ModifiedRealForVip)
}
ModifiedRealForVip::ModifiedRealForVip(const ModifiedRealForVip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifiedRealForVip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.real_){nullptr}
    , decltype(_impl_.vip_){nullptr}
    , decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_real()) {
    _this->_impl_.real_ = new ::lb::czkatran::Reals(*from._impl_.real_);
  }
  if (from._internal_has_vip()) {
    _this->_impl_.vip_ = new ::lb::czkatran::Vip(*from._impl_.vip_);
  }
  _this->_impl_.action_ = from._impl_.action_;
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.ModifiedRealForVip)
}

inline void ModifiedRealForVip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.real_){nullptr}
    , decltype(_impl_.vip_){nullptr}
    , decltype(_impl_.action_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModifiedRealForVip::~ModifiedRealForVip() {
  // @@protoc_insertion_point(destructor:lb.czkatran.ModifiedRealForVip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifiedRealForVip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.real_;
  if (this != internal_default_instance()) delete _impl_.vip_;
}

void ModifiedRealForVip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifiedRealForVip::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.ModifiedRealForVip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.real_ != nullptr) {
    delete _impl_.real_;
  }
  _impl_.real_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vip_ != nullptr) {
    delete _impl_.vip_;
  }
  _impl_.vip_ = nullptr;
  _impl_.action_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifiedRealForVip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .lb.czkatran.Action action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_action(static_cast<::lb::czkatran::Action>(val));
        } else
          goto handle_unusual;
        continue;
      // .lb.czkatran.Reals real = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_real(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .lb.czkatran.Vip vip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_vip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifiedRealForVip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.ModifiedRealForVip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .lb.czkatran.Action action = 1;
  if (this->_internal_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_action(), target);
  }

  // .lb.czkatran.Reals real = 2;
  if (this->_internal_has_real()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::real(this),
        _Internal::real(this).GetCachedSize(), target, stream);
  }

  // .lb.czkatran.Vip vip = 3;
  if (this->_internal_has_vip()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::vip(this),
        _Internal::vip(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.ModifiedRealForVip)
  return target;
}

size_t ModifiedRealForVip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.ModifiedRealForVip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .lb.czkatran.Reals real = 2;
  if (this->_internal_has_real()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.real_);
  }

  // .lb.czkatran.Vip vip = 3;
  if (this->_internal_has_vip()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vip_);
  }

  // .lb.czkatran.Action action = 1;
  if (this->_internal_action() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifiedRealForVip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifiedRealForVip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifiedRealForVip::GetClassData() const { return &_class_data_; }


void ModifiedRealForVip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifiedRealForVip*>(&to_msg);
  auto& from = static_cast<const ModifiedRealForVip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.ModifiedRealForVip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_real()) {
    _this->_internal_mutable_real()->::lb::czkatran::Reals::MergeFrom(
        from._internal_real());
  }
  if (from._internal_has_vip()) {
    _this->_internal_mutable_vip()->::lb::czkatran::Vip::MergeFrom(
        from._internal_vip());
  }
  if (from._internal_action() != 0) {
    _this->_internal_set_action(from._internal_action());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifiedRealForVip::CopyFrom(const ModifiedRealForVip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.ModifiedRealForVip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifiedRealForVip::IsInitialized() const {
  return true;
}

void ModifiedRealForVip::InternalSwap(ModifiedRealForVip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifiedRealForVip, _impl_.action_)
      + sizeof(ModifiedRealForVip::_impl_.action_)
      - PROTOBUF_FIELD_OFFSET(ModifiedRealForVip, _impl_.real_)>(
          reinterpret_cast<char*>(&_impl_.real_),
          reinterpret_cast<char*>(&other->_impl_.real_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifiedRealForVip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[15]);
}

// ===================================================================

class ModifiedQuicReals::_Internal {
 public:
  static const ::lb::czkatran::QuicReals& qreals(const ModifiedQuicReals* msg);
};

const ::lb::czkatran::QuicReals&
ModifiedQuicReals::_Internal::qreals(const ModifiedQuicReals* msg) {
  return *msg->_impl_.qreals_;
}
ModifiedQuicReals::ModifiedQuicReals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.ModifiedQuicReals)
}
ModifiedQuicReals::ModifiedQuicReals(const ModifiedQuicReals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifiedQuicReals* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.qreals_){nullptr}
    , decltype(_impl_.action_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_qreals()) {
    _this->_impl_.qreals_ = new ::lb::czkatran::QuicReals(*from._impl_.qreals_);
  }
  _this->_impl_.action_ = from._impl_.action_;
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.ModifiedQuicReals)
}

inline void ModifiedQuicReals::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.qreals_){nullptr}
    , decltype(_impl_.action_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModifiedQuicReals::~ModifiedQuicReals() {
  // @@protoc_insertion_point(destructor:lb.czkatran.ModifiedQuicReals)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifiedQuicReals::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.qreals_;
}

void ModifiedQuicReals::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifiedQuicReals::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.ModifiedQuicReals)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.qreals_ != nullptr) {
    delete _impl_.qreals_;
  }
  _impl_.qreals_ = nullptr;
  _impl_.action_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifiedQuicReals::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .lb.czkatran.Action action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_action(static_cast<::lb::czkatran::Action>(val));
        } else
          goto handle_unusual;
        continue;
      // .lb.czkatran.QuicReals qreals = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_qreals(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifiedQuicReals::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.ModifiedQuicReals)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .lb.czkatran.Action action = 1;
  if (this->_internal_action() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_action(), target);
  }

  // .lb.czkatran.QuicReals qreals = 2;
  if (this->_internal_has_qreals()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::qreals(this),
        _Internal::qreals(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.ModifiedQuicReals)
  return target;
}

size_t ModifiedQuicReals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.ModifiedQuicReals)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .lb.czkatran.QuicReals qreals = 2;
  if (this->_internal_has_qreals()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.qreals_);
  }

  // .lb.czkatran.Action action = 1;
  if (this->_internal_action() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifiedQuicReals::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifiedQuicReals::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifiedQuicReals::GetClassData() const { return &_class_data_; }


void ModifiedQuicReals::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifiedQuicReals*>(&to_msg);
  auto& from = static_cast<const ModifiedQuicReals&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.ModifiedQuicReals)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_qreals()) {
    _this->_internal_mutable_qreals()->::lb::czkatran::QuicReals::MergeFrom(
        from._internal_qreals());
  }
  if (from._internal_action() != 0) {
    _this->_internal_set_action(from._internal_action());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifiedQuicReals::CopyFrom(const ModifiedQuicReals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.ModifiedQuicReals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifiedQuicReals::IsInitialized() const {
  return true;
}

void ModifiedQuicReals::InternalSwap(ModifiedQuicReals* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifiedQuicReals, _impl_.action_)
      + sizeof(ModifiedQuicReals::_impl_.action_)
      - PROTOBUF_FIELD_OFFSET(ModifiedQuicReals, _impl_.qreals_)>(
          reinterpret_cast<char*>(&_impl_.qreals_),
          reinterpret_cast<char*>(&other->_impl_.qreals_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifiedQuicReals::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[16]);
}

// ===================================================================

class realForVip::_Internal {
 public:
  static const ::lb::czkatran::Real& real(const realForVip* msg);
  static const ::lb::czkatran::Vip& vip(const realForVip* msg);
};

const ::lb::czkatran::Real&
realForVip::_Internal::real(const realForVip* msg) {
  return *msg->_impl_.real_;
}
const ::lb::czkatran::Vip&
realForVip::_Internal::vip(const realForVip* msg) {
  return *msg->_impl_.vip_;
}
realForVip::realForVip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.realForVip)
}
realForVip::realForVip(const realForVip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  realForVip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.real_){nullptr}
    , decltype(_impl_.vip_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_real()) {
    _this->_impl_.real_ = new ::lb::czkatran::Real(*from._impl_.real_);
  }
  if (from._internal_has_vip()) {
    _this->_impl_.vip_ = new ::lb::czkatran::Vip(*from._impl_.vip_);
  }
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.realForVip)
}

inline void realForVip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.real_){nullptr}
    , decltype(_impl_.vip_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

realForVip::~realForVip() {
  // @@protoc_insertion_point(destructor:lb.czkatran.realForVip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void realForVip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.real_;
  if (this != internal_default_instance()) delete _impl_.vip_;
}

void realForVip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void realForVip::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.realForVip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.real_ != nullptr) {
    delete _impl_.real_;
  }
  _impl_.real_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vip_ != nullptr) {
    delete _impl_.vip_;
  }
  _impl_.vip_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* realForVip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .lb.czkatran.Real real = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_real(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .lb.czkatran.Vip vip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_vip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* realForVip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.realForVip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .lb.czkatran.Real real = 1;
  if (this->_internal_has_real()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::real(this),
        _Internal::real(this).GetCachedSize(), target, stream);
  }

  // .lb.czkatran.Vip vip = 2;
  if (this->_internal_has_vip()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::vip(this),
        _Internal::vip(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.realForVip)
  return target;
}

size_t realForVip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.realForVip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .lb.czkatran.Real real = 1;
  if (this->_internal_has_real()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.real_);
  }

  // .lb.czkatran.Vip vip = 2;
  if (this->_internal_has_vip()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vip_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData realForVip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    realForVip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*realForVip::GetClassData() const { return &_class_data_; }


void realForVip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<realForVip*>(&to_msg);
  auto& from = static_cast<const realForVip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.realForVip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_real()) {
    _this->_internal_mutable_real()->::lb::czkatran::Real::MergeFrom(
        from._internal_real());
  }
  if (from._internal_has_vip()) {
    _this->_internal_mutable_vip()->::lb::czkatran::Vip::MergeFrom(
        from._internal_vip());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void realForVip::CopyFrom(const realForVip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.realForVip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool realForVip::IsInitialized() const {
  return true;
}

void realForVip::InternalSwap(realForVip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(realForVip, _impl_.vip_)
      + sizeof(realForVip::_impl_.vip_)
      - PROTOBUF_FIELD_OFFSET(realForVip, _impl_.real_)>(
          reinterpret_cast<char*>(&_impl_.real_),
          reinterpret_cast<char*>(&other->_impl_.real_));
}

::PROTOBUF_NAMESPACE_ID::Metadata realForVip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[17]);
}

// ===================================================================

class Flags::_Internal {
 public:
};

Flags::Flags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Flags)
}
Flags::Flags(const Flags& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Flags* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flags_ = from._impl_.flags_;
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Flags)
}

inline void Flags::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flags_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Flags::~Flags() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Flags)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Flags::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Flags::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Flags::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Flags)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flags_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Flags::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Flags::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Flags)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 flags = 1;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Flags)
  return target;
}

size_t Flags::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Flags)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 flags = 1;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_flags());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Flags::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Flags::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Flags::GetClassData() const { return &_class_data_; }


void Flags::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Flags*>(&to_msg);
  auto& from = static_cast<const Flags&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Flags)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Flags::CopyFrom(const Flags& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Flags)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Flags::IsInitialized() const {
  return true;
}

void Flags::InternalSwap(Flags* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flags_, other->_impl_.flags_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Flags::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[18]);
}

// ===================================================================

class Somark::_Internal {
 public:
};

Somark::Somark(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:lb.czkatran.Somark)
}
Somark::Somark(const Somark& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Somark* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.somark_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.somark_ = from._impl_.somark_;
  // @@protoc_insertion_point(copy_constructor:lb.czkatran.Somark)
}

inline void Somark::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.somark_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Somark::~Somark() {
  // @@protoc_insertion_point(destructor:lb.czkatran.Somark)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Somark::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Somark::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Somark::Clear() {
// @@protoc_insertion_point(message_clear_start:lb.czkatran.Somark)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.somark_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Somark::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 somark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.somark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Somark::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lb.czkatran.Somark)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 somark = 1;
  if (this->_internal_somark() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_somark(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lb.czkatran.Somark)
  return target;
}

size_t Somark::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lb.czkatran.Somark)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 somark = 1;
  if (this->_internal_somark() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_somark());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Somark::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Somark::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Somark::GetClassData() const { return &_class_data_; }


void Somark::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Somark*>(&to_msg);
  auto& from = static_cast<const Somark&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:lb.czkatran.Somark)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_somark() != 0) {
    _this->_internal_set_somark(from._internal_somark());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Somark::CopyFrom(const Somark& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lb.czkatran.Somark)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Somark::IsInitialized() const {
  return true;
}

void Somark::InternalSwap(Somark* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.somark_, other->_impl_.somark_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Somark::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_czkatran_2eproto_getter, &descriptor_table_czkatran_2eproto_once,
      file_level_metadata_czkatran_2eproto[19]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace czkatran
}  // namespace lb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::lb::czkatran::Empty*
Arena::CreateMaybeMessage< ::lb::czkatran::Empty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Empty >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Bool*
Arena::CreateMaybeMessage< ::lb::czkatran::Bool >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Bool >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Vip*
Arena::CreateMaybeMessage< ::lb::czkatran::Vip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Vip >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::VipMeta*
Arena::CreateMaybeMessage< ::lb::czkatran::VipMeta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::VipMeta >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::RealMeta*
Arena::CreateMaybeMessage< ::lb::czkatran::RealMeta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::RealMeta >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Real*
Arena::CreateMaybeMessage< ::lb::czkatran::Real >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Real >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::QuicReal*
Arena::CreateMaybeMessage< ::lb::czkatran::QuicReal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::QuicReal >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Mac*
Arena::CreateMaybeMessage< ::lb::czkatran::Mac >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Mac >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Stats*
Arena::CreateMaybeMessage< ::lb::czkatran::Stats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Stats >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Healthcheck*
Arena::CreateMaybeMessage< ::lb::czkatran::Healthcheck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Healthcheck >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse*
Arena::CreateMaybeMessage< ::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::hcMap*
Arena::CreateMaybeMessage< ::lb::czkatran::hcMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::hcMap >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Reals*
Arena::CreateMaybeMessage< ::lb::czkatran::Reals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Reals >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Vips*
Arena::CreateMaybeMessage< ::lb::czkatran::Vips >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Vips >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::QuicReals*
Arena::CreateMaybeMessage< ::lb::czkatran::QuicReals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::QuicReals >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::ModifiedRealForVip*
Arena::CreateMaybeMessage< ::lb::czkatran::ModifiedRealForVip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::ModifiedRealForVip >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::ModifiedQuicReals*
Arena::CreateMaybeMessage< ::lb::czkatran::ModifiedQuicReals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::ModifiedQuicReals >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::realForVip*
Arena::CreateMaybeMessage< ::lb::czkatran::realForVip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::realForVip >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Flags*
Arena::CreateMaybeMessage< ::lb::czkatran::Flags >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Flags >(arena);
}
template<> PROTOBUF_NOINLINE ::lb::czkatran::Somark*
Arena::CreateMaybeMessage< ::lb::czkatran::Somark >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lb::czkatran::Somark >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
