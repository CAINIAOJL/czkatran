// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: czkatran.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_czkatran_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_czkatran_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_czkatran_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_czkatran_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_czkatran_2eproto;
namespace lb {
namespace czkatran {
class Bool;
struct BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Flags;
struct FlagsDefaultTypeInternal;
extern FlagsDefaultTypeInternal _Flags_default_instance_;
class Healthcheck;
struct HealthcheckDefaultTypeInternal;
extern HealthcheckDefaultTypeInternal _Healthcheck_default_instance_;
class Mac;
struct MacDefaultTypeInternal;
extern MacDefaultTypeInternal _Mac_default_instance_;
class ModifiedQuicReals;
struct ModifiedQuicRealsDefaultTypeInternal;
extern ModifiedQuicRealsDefaultTypeInternal _ModifiedQuicReals_default_instance_;
class ModifiedRealForVip;
struct ModifiedRealForVipDefaultTypeInternal;
extern ModifiedRealForVipDefaultTypeInternal _ModifiedRealForVip_default_instance_;
class QuicReal;
struct QuicRealDefaultTypeInternal;
extern QuicRealDefaultTypeInternal _QuicReal_default_instance_;
class QuicReals;
struct QuicRealsDefaultTypeInternal;
extern QuicRealsDefaultTypeInternal _QuicReals_default_instance_;
class Real;
struct RealDefaultTypeInternal;
extern RealDefaultTypeInternal _Real_default_instance_;
class RealMeta;
struct RealMetaDefaultTypeInternal;
extern RealMetaDefaultTypeInternal _RealMeta_default_instance_;
class Reals;
struct RealsDefaultTypeInternal;
extern RealsDefaultTypeInternal _Reals_default_instance_;
class Somark;
struct SomarkDefaultTypeInternal;
extern SomarkDefaultTypeInternal _Somark_default_instance_;
class Stats;
struct StatsDefaultTypeInternal;
extern StatsDefaultTypeInternal _Stats_default_instance_;
class Vip;
struct VipDefaultTypeInternal;
extern VipDefaultTypeInternal _Vip_default_instance_;
class VipMeta;
struct VipMetaDefaultTypeInternal;
extern VipMetaDefaultTypeInternal _VipMeta_default_instance_;
class Vips;
struct VipsDefaultTypeInternal;
extern VipsDefaultTypeInternal _Vips_default_instance_;
class hcMap;
struct hcMapDefaultTypeInternal;
extern hcMapDefaultTypeInternal _hcMap_default_instance_;
class hcMap_HealthchecksEntry_DoNotUse;
struct hcMap_HealthchecksEntry_DoNotUseDefaultTypeInternal;
extern hcMap_HealthchecksEntry_DoNotUseDefaultTypeInternal _hcMap_HealthchecksEntry_DoNotUse_default_instance_;
class realForVip;
struct realForVipDefaultTypeInternal;
extern realForVipDefaultTypeInternal _realForVip_default_instance_;
}  // namespace czkatran
}  // namespace lb
PROTOBUF_NAMESPACE_OPEN
template<> ::lb::czkatran::Bool* Arena::CreateMaybeMessage<::lb::czkatran::Bool>(Arena*);
template<> ::lb::czkatran::Empty* Arena::CreateMaybeMessage<::lb::czkatran::Empty>(Arena*);
template<> ::lb::czkatran::Flags* Arena::CreateMaybeMessage<::lb::czkatran::Flags>(Arena*);
template<> ::lb::czkatran::Healthcheck* Arena::CreateMaybeMessage<::lb::czkatran::Healthcheck>(Arena*);
template<> ::lb::czkatran::Mac* Arena::CreateMaybeMessage<::lb::czkatran::Mac>(Arena*);
template<> ::lb::czkatran::ModifiedQuicReals* Arena::CreateMaybeMessage<::lb::czkatran::ModifiedQuicReals>(Arena*);
template<> ::lb::czkatran::ModifiedRealForVip* Arena::CreateMaybeMessage<::lb::czkatran::ModifiedRealForVip>(Arena*);
template<> ::lb::czkatran::QuicReal* Arena::CreateMaybeMessage<::lb::czkatran::QuicReal>(Arena*);
template<> ::lb::czkatran::QuicReals* Arena::CreateMaybeMessage<::lb::czkatran::QuicReals>(Arena*);
template<> ::lb::czkatran::Real* Arena::CreateMaybeMessage<::lb::czkatran::Real>(Arena*);
template<> ::lb::czkatran::RealMeta* Arena::CreateMaybeMessage<::lb::czkatran::RealMeta>(Arena*);
template<> ::lb::czkatran::Reals* Arena::CreateMaybeMessage<::lb::czkatran::Reals>(Arena*);
template<> ::lb::czkatran::Somark* Arena::CreateMaybeMessage<::lb::czkatran::Somark>(Arena*);
template<> ::lb::czkatran::Stats* Arena::CreateMaybeMessage<::lb::czkatran::Stats>(Arena*);
template<> ::lb::czkatran::Vip* Arena::CreateMaybeMessage<::lb::czkatran::Vip>(Arena*);
template<> ::lb::czkatran::VipMeta* Arena::CreateMaybeMessage<::lb::czkatran::VipMeta>(Arena*);
template<> ::lb::czkatran::Vips* Arena::CreateMaybeMessage<::lb::czkatran::Vips>(Arena*);
template<> ::lb::czkatran::hcMap* Arena::CreateMaybeMessage<::lb::czkatran::hcMap>(Arena*);
template<> ::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse* Arena::CreateMaybeMessage<::lb::czkatran::hcMap_HealthchecksEntry_DoNotUse>(Arena*);
template<> ::lb::czkatran::realForVip* Arena::CreateMaybeMessage<::lb::czkatran::realForVip>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace lb {
namespace czkatran {

enum Action : int {
  ADD = 0,
  DEl = 1,
  Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Action_IsValid(int value);
constexpr Action Action_MIN = ADD;
constexpr Action Action_MAX = DEl;
constexpr int Action_ARRAYSIZE = Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Action_descriptor();
template<typename T>
inline const std::string& Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Action_descriptor(), enum_t_value);
}
inline bool Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:lb.czkatran.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lb.czkatran.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Bool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Bool) */ {
 public:
  inline Bool() : Bool(nullptr) {}
  ~Bool() override;
  explicit PROTOBUF_CONSTEXPR Bool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bool(const Bool& from);
  Bool(Bool&& from) noexcept
    : Bool() {
    *this = ::std::move(from);
  }

  inline Bool& operator=(const Bool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bool& operator=(Bool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bool* internal_default_instance() {
    return reinterpret_cast<const Bool*>(
               &_Bool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Bool& a, Bool& b) {
    a.Swap(&b);
  }
  inline void Swap(Bool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bool& from) {
    Bool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Bool";
  }
  protected:
  explicit Bool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.Bool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Vip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Vip) */ {
 public:
  inline Vip() : Vip(nullptr) {}
  ~Vip() override;
  explicit PROTOBUF_CONSTEXPR Vip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vip(const Vip& from);
  Vip(Vip&& from) noexcept
    : Vip() {
    *this = ::std::move(from);
  }

  inline Vip& operator=(const Vip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vip& operator=(Vip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vip* internal_default_instance() {
    return reinterpret_cast<const Vip*>(
               &_Vip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vip& a, Vip& b) {
    a.Swap(&b);
  }
  inline void Swap(Vip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vip& from) {
    Vip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Vip";
  }
  protected:
  explicit Vip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPortFieldNumber = 2,
    kProtocolFieldNumber = 3,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // int32 protocol = 3;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.Vip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t port_;
    int32_t protocol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class VipMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.VipMeta) */ {
 public:
  inline VipMeta() : VipMeta(nullptr) {}
  ~VipMeta() override;
  explicit PROTOBUF_CONSTEXPR VipMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VipMeta(const VipMeta& from);
  VipMeta(VipMeta&& from) noexcept
    : VipMeta() {
    *this = ::std::move(from);
  }

  inline VipMeta& operator=(const VipMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline VipMeta& operator=(VipMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VipMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const VipMeta* internal_default_instance() {
    return reinterpret_cast<const VipMeta*>(
               &_VipMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VipMeta& a, VipMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(VipMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VipMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VipMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VipMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VipMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VipMeta& from) {
    VipMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VipMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.VipMeta";
  }
  protected:
  explicit VipMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVipFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kSetflagsFieldNumber = 3,
  };
  // .lb.czkatran.Vip vip = 1;
  bool has_vip() const;
  private:
  bool _internal_has_vip() const;
  public:
  void clear_vip();
  const ::lb::czkatran::Vip& vip() const;
  PROTOBUF_NODISCARD ::lb::czkatran::Vip* release_vip();
  ::lb::czkatran::Vip* mutable_vip();
  void set_allocated_vip(::lb::czkatran::Vip* vip);
  private:
  const ::lb::czkatran::Vip& _internal_vip() const;
  ::lb::czkatran::Vip* _internal_mutable_vip();
  public:
  void unsafe_arena_set_allocated_vip(
      ::lb::czkatran::Vip* vip);
  ::lb::czkatran::Vip* unsafe_arena_release_vip();

  // int64 flags = 2;
  void clear_flags();
  int64_t flags() const;
  void set_flags(int64_t value);
  private:
  int64_t _internal_flags() const;
  void _internal_set_flags(int64_t value);
  public:

  // bool setflags = 3;
  void clear_setflags();
  bool setflags() const;
  void set_setflags(bool value);
  private:
  bool _internal_setflags() const;
  void _internal_set_setflags(bool value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.VipMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::lb::czkatran::Vip* vip_;
    int64_t flags_;
    bool setflags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class RealMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.RealMeta) */ {
 public:
  inline RealMeta() : RealMeta(nullptr) {}
  ~RealMeta() override;
  explicit PROTOBUF_CONSTEXPR RealMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RealMeta(const RealMeta& from);
  RealMeta(RealMeta&& from) noexcept
    : RealMeta() {
    *this = ::std::move(from);
  }

  inline RealMeta& operator=(const RealMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline RealMeta& operator=(RealMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RealMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const RealMeta* internal_default_instance() {
    return reinterpret_cast<const RealMeta*>(
               &_RealMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RealMeta& a, RealMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(RealMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RealMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RealMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RealMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RealMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RealMeta& from) {
    RealMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RealMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.RealMeta";
  }
  protected:
  explicit RealMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kSetflagsFieldNumber = 3,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int32 flags = 2;
  void clear_flags();
  int32_t flags() const;
  void set_flags(int32_t value);
  private:
  int32_t _internal_flags() const;
  void _internal_set_flags(int32_t value);
  public:

  // bool setflags = 3;
  void clear_setflags();
  bool setflags() const;
  void set_setflags(bool value);
  private:
  bool _internal_setflags() const;
  void _internal_set_setflags(bool value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.RealMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t flags_;
    bool setflags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Real final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Real) */ {
 public:
  inline Real() : Real(nullptr) {}
  ~Real() override;
  explicit PROTOBUF_CONSTEXPR Real(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Real(const Real& from);
  Real(Real&& from) noexcept
    : Real() {
    *this = ::std::move(from);
  }

  inline Real& operator=(const Real& from) {
    CopyFrom(from);
    return *this;
  }
  inline Real& operator=(Real&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Real& default_instance() {
    return *internal_default_instance();
  }
  static inline const Real* internal_default_instance() {
    return reinterpret_cast<const Real*>(
               &_Real_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Real& a, Real& b) {
    a.Swap(&b);
  }
  inline void Swap(Real* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Real* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Real* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Real>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Real& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Real& from) {
    Real::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Real* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Real";
  }
  protected:
  explicit Real(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kWeightFieldNumber = 2,
    kFlagsFieldNumber = 3,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int32 weight = 2;
  void clear_weight();
  int32_t weight() const;
  void set_weight(int32_t value);
  private:
  int32_t _internal_weight() const;
  void _internal_set_weight(int32_t value);
  public:

  // int32 flags = 3;
  void clear_flags();
  int32_t flags() const;
  void set_flags(int32_t value);
  private:
  int32_t _internal_flags() const;
  void _internal_set_flags(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.Real)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t weight_;
    int32_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class QuicReal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.QuicReal) */ {
 public:
  inline QuicReal() : QuicReal(nullptr) {}
  ~QuicReal() override;
  explicit PROTOBUF_CONSTEXPR QuicReal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuicReal(const QuicReal& from);
  QuicReal(QuicReal&& from) noexcept
    : QuicReal() {
    *this = ::std::move(from);
  }

  inline QuicReal& operator=(const QuicReal& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuicReal& operator=(QuicReal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuicReal& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuicReal* internal_default_instance() {
    return reinterpret_cast<const QuicReal*>(
               &_QuicReal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QuicReal& a, QuicReal& b) {
    a.Swap(&b);
  }
  inline void Swap(QuicReal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuicReal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuicReal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuicReal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuicReal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuicReal& from) {
    QuicReal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuicReal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.QuicReal";
  }
  protected:
  explicit QuicReal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.QuicReal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Mac final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Mac) */ {
 public:
  inline Mac() : Mac(nullptr) {}
  ~Mac() override;
  explicit PROTOBUF_CONSTEXPR Mac(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mac(const Mac& from);
  Mac(Mac&& from) noexcept
    : Mac() {
    *this = ::std::move(from);
  }

  inline Mac& operator=(const Mac& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mac& operator=(Mac&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mac& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mac* internal_default_instance() {
    return reinterpret_cast<const Mac*>(
               &_Mac_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Mac& a, Mac& b) {
    a.Swap(&b);
  }
  inline void Swap(Mac* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mac* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mac* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mac>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mac& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mac& from) {
    Mac::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mac* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Mac";
  }
  protected:
  explicit Mac(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacFieldNumber = 1,
  };
  // string mac = 1;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.Mac)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Stats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Stats) */ {
 public:
  inline Stats() : Stats(nullptr) {}
  ~Stats() override;
  explicit PROTOBUF_CONSTEXPR Stats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stats(const Stats& from);
  Stats(Stats&& from) noexcept
    : Stats() {
    *this = ::std::move(from);
  }

  inline Stats& operator=(const Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stats& operator=(Stats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stats& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stats* internal_default_instance() {
    return reinterpret_cast<const Stats*>(
               &_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Stats& a, Stats& b) {
    a.Swap(&b);
  }
  inline void Swap(Stats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stats& from) {
    Stats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Stats";
  }
  protected:
  explicit Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 1,
    kV2FieldNumber = 2,
  };
  // uint64 v1 = 1;
  void clear_v1();
  uint64_t v1() const;
  void set_v1(uint64_t value);
  private:
  uint64_t _internal_v1() const;
  void _internal_set_v1(uint64_t value);
  public:

  // uint64 v2 = 2;
  void clear_v2();
  uint64_t v2() const;
  void set_v2(uint64_t value);
  private:
  uint64_t _internal_v2() const;
  void _internal_set_v2(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.Stats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t v1_;
    uint64_t v2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Healthcheck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Healthcheck) */ {
 public:
  inline Healthcheck() : Healthcheck(nullptr) {}
  ~Healthcheck() override;
  explicit PROTOBUF_CONSTEXPR Healthcheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Healthcheck(const Healthcheck& from);
  Healthcheck(Healthcheck&& from) noexcept
    : Healthcheck() {
    *this = ::std::move(from);
  }

  inline Healthcheck& operator=(const Healthcheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline Healthcheck& operator=(Healthcheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Healthcheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const Healthcheck* internal_default_instance() {
    return reinterpret_cast<const Healthcheck*>(
               &_Healthcheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Healthcheck& a, Healthcheck& b) {
    a.Swap(&b);
  }
  inline void Swap(Healthcheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Healthcheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Healthcheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Healthcheck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Healthcheck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Healthcheck& from) {
    Healthcheck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Healthcheck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Healthcheck";
  }
  protected:
  explicit Healthcheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kSomarkFieldNumber = 1,
  };
  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint32 somark = 1;
  void clear_somark();
  uint32_t somark() const;
  void set_somark(uint32_t value);
  private:
  uint32_t _internal_somark() const;
  void _internal_set_somark(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.Healthcheck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    uint32_t somark_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class hcMap_HealthchecksEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<hcMap_HealthchecksEntry_DoNotUse, 
    int32_t, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<hcMap_HealthchecksEntry_DoNotUse, 
    int32_t, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  hcMap_HealthchecksEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR hcMap_HealthchecksEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit hcMap_HealthchecksEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const hcMap_HealthchecksEntry_DoNotUse& other);
  static const hcMap_HealthchecksEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const hcMap_HealthchecksEntry_DoNotUse*>(&_hcMap_HealthchecksEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "lb.czkatran.hcMap.HealthchecksEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_czkatran_2eproto;
};

// -------------------------------------------------------------------

class hcMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.hcMap) */ {
 public:
  inline hcMap() : hcMap(nullptr) {}
  ~hcMap() override;
  explicit PROTOBUF_CONSTEXPR hcMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  hcMap(const hcMap& from);
  hcMap(hcMap&& from) noexcept
    : hcMap() {
    *this = ::std::move(from);
  }

  inline hcMap& operator=(const hcMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline hcMap& operator=(hcMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const hcMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const hcMap* internal_default_instance() {
    return reinterpret_cast<const hcMap*>(
               &_hcMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(hcMap& a, hcMap& b) {
    a.Swap(&b);
  }
  inline void Swap(hcMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(hcMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  hcMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<hcMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const hcMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const hcMap& from) {
    hcMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(hcMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.hcMap";
  }
  protected:
  explicit hcMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHealthchecksFieldNumber = 1,
  };
  // map<int32, string> healthchecks = 1;
  int healthchecks_size() const;
  private:
  int _internal_healthchecks_size() const;
  public:
  void clear_healthchecks();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
      _internal_healthchecks() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
      _internal_mutable_healthchecks();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
      healthchecks() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
      mutable_healthchecks();

  // @@protoc_insertion_point(class_scope:lb.czkatran.hcMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        hcMap_HealthchecksEntry_DoNotUse,
        int32_t, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> healthchecks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Reals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Reals) */ {
 public:
  inline Reals() : Reals(nullptr) {}
  ~Reals() override;
  explicit PROTOBUF_CONSTEXPR Reals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reals(const Reals& from);
  Reals(Reals&& from) noexcept
    : Reals() {
    *this = ::std::move(from);
  }

  inline Reals& operator=(const Reals& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reals& operator=(Reals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reals& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reals* internal_default_instance() {
    return reinterpret_cast<const Reals*>(
               &_Reals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Reals& a, Reals& b) {
    a.Swap(&b);
  }
  inline void Swap(Reals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Reals& from) {
    Reals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Reals";
  }
  protected:
  explicit Reals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealsFieldNumber = 1,
  };
  // repeated .lb.czkatran.Real reals = 1;
  int reals_size() const;
  private:
  int _internal_reals_size() const;
  public:
  void clear_reals();
  ::lb::czkatran::Real* mutable_reals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Real >*
      mutable_reals();
  private:
  const ::lb::czkatran::Real& _internal_reals(int index) const;
  ::lb::czkatran::Real* _internal_add_reals();
  public:
  const ::lb::czkatran::Real& reals(int index) const;
  ::lb::czkatran::Real* add_reals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Real >&
      reals() const;

  // @@protoc_insertion_point(class_scope:lb.czkatran.Reals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Real > reals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Vips final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Vips) */ {
 public:
  inline Vips() : Vips(nullptr) {}
  ~Vips() override;
  explicit PROTOBUF_CONSTEXPR Vips(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vips(const Vips& from);
  Vips(Vips&& from) noexcept
    : Vips() {
    *this = ::std::move(from);
  }

  inline Vips& operator=(const Vips& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vips& operator=(Vips&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vips& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vips* internal_default_instance() {
    return reinterpret_cast<const Vips*>(
               &_Vips_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Vips& a, Vips& b) {
    a.Swap(&b);
  }
  inline void Swap(Vips* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vips* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vips* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vips>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vips& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vips& from) {
    Vips::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vips* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Vips";
  }
  protected:
  explicit Vips(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVipsFieldNumber = 1,
  };
  // repeated .lb.czkatran.Vip vips = 1;
  int vips_size() const;
  private:
  int _internal_vips_size() const;
  public:
  void clear_vips();
  ::lb::czkatran::Vip* mutable_vips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Vip >*
      mutable_vips();
  private:
  const ::lb::czkatran::Vip& _internal_vips(int index) const;
  ::lb::czkatran::Vip* _internal_add_vips();
  public:
  const ::lb::czkatran::Vip& vips(int index) const;
  ::lb::czkatran::Vip* add_vips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Vip >&
      vips() const;

  // @@protoc_insertion_point(class_scope:lb.czkatran.Vips)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Vip > vips_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class QuicReals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.QuicReals) */ {
 public:
  inline QuicReals() : QuicReals(nullptr) {}
  ~QuicReals() override;
  explicit PROTOBUF_CONSTEXPR QuicReals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuicReals(const QuicReals& from);
  QuicReals(QuicReals&& from) noexcept
    : QuicReals() {
    *this = ::std::move(from);
  }

  inline QuicReals& operator=(const QuicReals& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuicReals& operator=(QuicReals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuicReals& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuicReals* internal_default_instance() {
    return reinterpret_cast<const QuicReals*>(
               &_QuicReals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(QuicReals& a, QuicReals& b) {
    a.Swap(&b);
  }
  inline void Swap(QuicReals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuicReals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuicReals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuicReals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuicReals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuicReals& from) {
    QuicReals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuicReals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.QuicReals";
  }
  protected:
  explicit QuicReals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQrealsFieldNumber = 1,
  };
  // repeated .lb.czkatran.QuicReal qreals = 1;
  int qreals_size() const;
  private:
  int _internal_qreals_size() const;
  public:
  void clear_qreals();
  ::lb::czkatran::QuicReal* mutable_qreals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::QuicReal >*
      mutable_qreals();
  private:
  const ::lb::czkatran::QuicReal& _internal_qreals(int index) const;
  ::lb::czkatran::QuicReal* _internal_add_qreals();
  public:
  const ::lb::czkatran::QuicReal& qreals(int index) const;
  ::lb::czkatran::QuicReal* add_qreals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::QuicReal >&
      qreals() const;

  // @@protoc_insertion_point(class_scope:lb.czkatran.QuicReals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::QuicReal > qreals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class ModifiedRealForVip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.ModifiedRealForVip) */ {
 public:
  inline ModifiedRealForVip() : ModifiedRealForVip(nullptr) {}
  ~ModifiedRealForVip() override;
  explicit PROTOBUF_CONSTEXPR ModifiedRealForVip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifiedRealForVip(const ModifiedRealForVip& from);
  ModifiedRealForVip(ModifiedRealForVip&& from) noexcept
    : ModifiedRealForVip() {
    *this = ::std::move(from);
  }

  inline ModifiedRealForVip& operator=(const ModifiedRealForVip& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifiedRealForVip& operator=(ModifiedRealForVip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifiedRealForVip& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifiedRealForVip* internal_default_instance() {
    return reinterpret_cast<const ModifiedRealForVip*>(
               &_ModifiedRealForVip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ModifiedRealForVip& a, ModifiedRealForVip& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifiedRealForVip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifiedRealForVip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifiedRealForVip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifiedRealForVip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifiedRealForVip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifiedRealForVip& from) {
    ModifiedRealForVip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifiedRealForVip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.ModifiedRealForVip";
  }
  protected:
  explicit ModifiedRealForVip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealFieldNumber = 2,
    kVipFieldNumber = 3,
    kActionFieldNumber = 1,
  };
  // .lb.czkatran.Reals real = 2;
  bool has_real() const;
  private:
  bool _internal_has_real() const;
  public:
  void clear_real();
  const ::lb::czkatran::Reals& real() const;
  PROTOBUF_NODISCARD ::lb::czkatran::Reals* release_real();
  ::lb::czkatran::Reals* mutable_real();
  void set_allocated_real(::lb::czkatran::Reals* real);
  private:
  const ::lb::czkatran::Reals& _internal_real() const;
  ::lb::czkatran::Reals* _internal_mutable_real();
  public:
  void unsafe_arena_set_allocated_real(
      ::lb::czkatran::Reals* real);
  ::lb::czkatran::Reals* unsafe_arena_release_real();

  // .lb.czkatran.Vip vip = 3;
  bool has_vip() const;
  private:
  bool _internal_has_vip() const;
  public:
  void clear_vip();
  const ::lb::czkatran::Vip& vip() const;
  PROTOBUF_NODISCARD ::lb::czkatran::Vip* release_vip();
  ::lb::czkatran::Vip* mutable_vip();
  void set_allocated_vip(::lb::czkatran::Vip* vip);
  private:
  const ::lb::czkatran::Vip& _internal_vip() const;
  ::lb::czkatran::Vip* _internal_mutable_vip();
  public:
  void unsafe_arena_set_allocated_vip(
      ::lb::czkatran::Vip* vip);
  ::lb::czkatran::Vip* unsafe_arena_release_vip();

  // .lb.czkatran.Action action = 1;
  void clear_action();
  ::lb::czkatran::Action action() const;
  void set_action(::lb::czkatran::Action value);
  private:
  ::lb::czkatran::Action _internal_action() const;
  void _internal_set_action(::lb::czkatran::Action value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.ModifiedRealForVip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::lb::czkatran::Reals* real_;
    ::lb::czkatran::Vip* vip_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class ModifiedQuicReals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.ModifiedQuicReals) */ {
 public:
  inline ModifiedQuicReals() : ModifiedQuicReals(nullptr) {}
  ~ModifiedQuicReals() override;
  explicit PROTOBUF_CONSTEXPR ModifiedQuicReals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifiedQuicReals(const ModifiedQuicReals& from);
  ModifiedQuicReals(ModifiedQuicReals&& from) noexcept
    : ModifiedQuicReals() {
    *this = ::std::move(from);
  }

  inline ModifiedQuicReals& operator=(const ModifiedQuicReals& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifiedQuicReals& operator=(ModifiedQuicReals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifiedQuicReals& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifiedQuicReals* internal_default_instance() {
    return reinterpret_cast<const ModifiedQuicReals*>(
               &_ModifiedQuicReals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ModifiedQuicReals& a, ModifiedQuicReals& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifiedQuicReals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifiedQuicReals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifiedQuicReals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifiedQuicReals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifiedQuicReals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifiedQuicReals& from) {
    ModifiedQuicReals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifiedQuicReals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.ModifiedQuicReals";
  }
  protected:
  explicit ModifiedQuicReals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQrealsFieldNumber = 2,
    kActionFieldNumber = 1,
  };
  // .lb.czkatran.QuicReals qreals = 2;
  bool has_qreals() const;
  private:
  bool _internal_has_qreals() const;
  public:
  void clear_qreals();
  const ::lb::czkatran::QuicReals& qreals() const;
  PROTOBUF_NODISCARD ::lb::czkatran::QuicReals* release_qreals();
  ::lb::czkatran::QuicReals* mutable_qreals();
  void set_allocated_qreals(::lb::czkatran::QuicReals* qreals);
  private:
  const ::lb::czkatran::QuicReals& _internal_qreals() const;
  ::lb::czkatran::QuicReals* _internal_mutable_qreals();
  public:
  void unsafe_arena_set_allocated_qreals(
      ::lb::czkatran::QuicReals* qreals);
  ::lb::czkatran::QuicReals* unsafe_arena_release_qreals();

  // .lb.czkatran.Action action = 1;
  void clear_action();
  ::lb::czkatran::Action action() const;
  void set_action(::lb::czkatran::Action value);
  private:
  ::lb::czkatran::Action _internal_action() const;
  void _internal_set_action(::lb::czkatran::Action value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.ModifiedQuicReals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::lb::czkatran::QuicReals* qreals_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class realForVip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.realForVip) */ {
 public:
  inline realForVip() : realForVip(nullptr) {}
  ~realForVip() override;
  explicit PROTOBUF_CONSTEXPR realForVip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  realForVip(const realForVip& from);
  realForVip(realForVip&& from) noexcept
    : realForVip() {
    *this = ::std::move(from);
  }

  inline realForVip& operator=(const realForVip& from) {
    CopyFrom(from);
    return *this;
  }
  inline realForVip& operator=(realForVip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const realForVip& default_instance() {
    return *internal_default_instance();
  }
  static inline const realForVip* internal_default_instance() {
    return reinterpret_cast<const realForVip*>(
               &_realForVip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(realForVip& a, realForVip& b) {
    a.Swap(&b);
  }
  inline void Swap(realForVip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(realForVip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  realForVip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<realForVip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const realForVip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const realForVip& from) {
    realForVip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(realForVip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.realForVip";
  }
  protected:
  explicit realForVip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRealFieldNumber = 1,
    kVipFieldNumber = 2,
  };
  // .lb.czkatran.Real real = 1;
  bool has_real() const;
  private:
  bool _internal_has_real() const;
  public:
  void clear_real();
  const ::lb::czkatran::Real& real() const;
  PROTOBUF_NODISCARD ::lb::czkatran::Real* release_real();
  ::lb::czkatran::Real* mutable_real();
  void set_allocated_real(::lb::czkatran::Real* real);
  private:
  const ::lb::czkatran::Real& _internal_real() const;
  ::lb::czkatran::Real* _internal_mutable_real();
  public:
  void unsafe_arena_set_allocated_real(
      ::lb::czkatran::Real* real);
  ::lb::czkatran::Real* unsafe_arena_release_real();

  // .lb.czkatran.Vip vip = 2;
  bool has_vip() const;
  private:
  bool _internal_has_vip() const;
  public:
  void clear_vip();
  const ::lb::czkatran::Vip& vip() const;
  PROTOBUF_NODISCARD ::lb::czkatran::Vip* release_vip();
  ::lb::czkatran::Vip* mutable_vip();
  void set_allocated_vip(::lb::czkatran::Vip* vip);
  private:
  const ::lb::czkatran::Vip& _internal_vip() const;
  ::lb::czkatran::Vip* _internal_mutable_vip();
  public:
  void unsafe_arena_set_allocated_vip(
      ::lb::czkatran::Vip* vip);
  ::lb::czkatran::Vip* unsafe_arena_release_vip();

  // @@protoc_insertion_point(class_scope:lb.czkatran.realForVip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::lb::czkatran::Real* real_;
    ::lb::czkatran::Vip* vip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Flags final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Flags) */ {
 public:
  inline Flags() : Flags(nullptr) {}
  ~Flags() override;
  explicit PROTOBUF_CONSTEXPR Flags(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Flags(const Flags& from);
  Flags(Flags&& from) noexcept
    : Flags() {
    *this = ::std::move(from);
  }

  inline Flags& operator=(const Flags& from) {
    CopyFrom(from);
    return *this;
  }
  inline Flags& operator=(Flags&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Flags& default_instance() {
    return *internal_default_instance();
  }
  static inline const Flags* internal_default_instance() {
    return reinterpret_cast<const Flags*>(
               &_Flags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Flags& a, Flags& b) {
    a.Swap(&b);
  }
  inline void Swap(Flags* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Flags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Flags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Flags>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Flags& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Flags& from) {
    Flags::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flags* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Flags";
  }
  protected:
  explicit Flags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagsFieldNumber = 1,
  };
  // uint64 flags = 1;
  void clear_flags();
  uint64_t flags() const;
  void set_flags(uint64_t value);
  private:
  uint64_t _internal_flags() const;
  void _internal_set_flags(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.Flags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// -------------------------------------------------------------------

class Somark final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lb.czkatran.Somark) */ {
 public:
  inline Somark() : Somark(nullptr) {}
  ~Somark() override;
  explicit PROTOBUF_CONSTEXPR Somark(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Somark(const Somark& from);
  Somark(Somark&& from) noexcept
    : Somark() {
    *this = ::std::move(from);
  }

  inline Somark& operator=(const Somark& from) {
    CopyFrom(from);
    return *this;
  }
  inline Somark& operator=(Somark&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Somark& default_instance() {
    return *internal_default_instance();
  }
  static inline const Somark* internal_default_instance() {
    return reinterpret_cast<const Somark*>(
               &_Somark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Somark& a, Somark& b) {
    a.Swap(&b);
  }
  inline void Swap(Somark* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Somark* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Somark* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Somark>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Somark& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Somark& from) {
    Somark::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Somark* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lb.czkatran.Somark";
  }
  protected:
  explicit Somark(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSomarkFieldNumber = 1,
  };
  // uint32 somark = 1;
  void clear_somark();
  uint32_t somark() const;
  void set_somark(uint32_t value);
  private:
  uint32_t _internal_somark() const;
  void _internal_set_somark(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:lb.czkatran.Somark)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t somark_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_czkatran_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Bool

// bool success = 1;
inline void Bool::clear_success() {
  _impl_.success_ = false;
}
inline bool Bool::_internal_success() const {
  return _impl_.success_;
}
inline bool Bool::success() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Bool.success)
  return _internal_success();
}
inline void Bool::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void Bool::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Bool.success)
}

// -------------------------------------------------------------------

// Vip

// string address = 1;
inline void Vip::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Vip::address() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Vip.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vip::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:lb.czkatran.Vip.address)
}
inline std::string* Vip::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.Vip.address)
  return _s;
}
inline const std::string& Vip::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Vip::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Vip::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Vip::release_address() {
  // @@protoc_insertion_point(field_release:lb.czkatran.Vip.address)
  return _impl_.address_.Release();
}
inline void Vip::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.Vip.address)
}

// int32 port = 2;
inline void Vip::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t Vip::_internal_port() const {
  return _impl_.port_;
}
inline int32_t Vip::port() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Vip.port)
  return _internal_port();
}
inline void Vip::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void Vip::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Vip.port)
}

// int32 protocol = 3;
inline void Vip::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline int32_t Vip::_internal_protocol() const {
  return _impl_.protocol_;
}
inline int32_t Vip::protocol() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Vip.protocol)
  return _internal_protocol();
}
inline void Vip::_internal_set_protocol(int32_t value) {
  
  _impl_.protocol_ = value;
}
inline void Vip::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Vip.protocol)
}

// -------------------------------------------------------------------

// VipMeta

// .lb.czkatran.Vip vip = 1;
inline bool VipMeta::_internal_has_vip() const {
  return this != internal_default_instance() && _impl_.vip_ != nullptr;
}
inline bool VipMeta::has_vip() const {
  return _internal_has_vip();
}
inline void VipMeta::clear_vip() {
  if (GetArenaForAllocation() == nullptr && _impl_.vip_ != nullptr) {
    delete _impl_.vip_;
  }
  _impl_.vip_ = nullptr;
}
inline const ::lb::czkatran::Vip& VipMeta::_internal_vip() const {
  const ::lb::czkatran::Vip* p = _impl_.vip_;
  return p != nullptr ? *p : reinterpret_cast<const ::lb::czkatran::Vip&>(
      ::lb::czkatran::_Vip_default_instance_);
}
inline const ::lb::czkatran::Vip& VipMeta::vip() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.VipMeta.vip)
  return _internal_vip();
}
inline void VipMeta::unsafe_arena_set_allocated_vip(
    ::lb::czkatran::Vip* vip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vip_);
  }
  _impl_.vip_ = vip;
  if (vip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lb.czkatran.VipMeta.vip)
}
inline ::lb::czkatran::Vip* VipMeta::release_vip() {
  
  ::lb::czkatran::Vip* temp = _impl_.vip_;
  _impl_.vip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::lb::czkatran::Vip* VipMeta::unsafe_arena_release_vip() {
  // @@protoc_insertion_point(field_release:lb.czkatran.VipMeta.vip)
  
  ::lb::czkatran::Vip* temp = _impl_.vip_;
  _impl_.vip_ = nullptr;
  return temp;
}
inline ::lb::czkatran::Vip* VipMeta::_internal_mutable_vip() {
  
  if (_impl_.vip_ == nullptr) {
    auto* p = CreateMaybeMessage<::lb::czkatran::Vip>(GetArenaForAllocation());
    _impl_.vip_ = p;
  }
  return _impl_.vip_;
}
inline ::lb::czkatran::Vip* VipMeta::mutable_vip() {
  ::lb::czkatran::Vip* _msg = _internal_mutable_vip();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.VipMeta.vip)
  return _msg;
}
inline void VipMeta::set_allocated_vip(::lb::czkatran::Vip* vip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vip_;
  }
  if (vip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vip);
    if (message_arena != submessage_arena) {
      vip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vip_ = vip;
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.VipMeta.vip)
}

// int64 flags = 2;
inline void VipMeta::clear_flags() {
  _impl_.flags_ = int64_t{0};
}
inline int64_t VipMeta::_internal_flags() const {
  return _impl_.flags_;
}
inline int64_t VipMeta::flags() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.VipMeta.flags)
  return _internal_flags();
}
inline void VipMeta::_internal_set_flags(int64_t value) {
  
  _impl_.flags_ = value;
}
inline void VipMeta::set_flags(int64_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.VipMeta.flags)
}

// bool setflags = 3;
inline void VipMeta::clear_setflags() {
  _impl_.setflags_ = false;
}
inline bool VipMeta::_internal_setflags() const {
  return _impl_.setflags_;
}
inline bool VipMeta::setflags() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.VipMeta.setflags)
  return _internal_setflags();
}
inline void VipMeta::_internal_set_setflags(bool value) {
  
  _impl_.setflags_ = value;
}
inline void VipMeta::set_setflags(bool value) {
  _internal_set_setflags(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.VipMeta.setflags)
}

// -------------------------------------------------------------------

// RealMeta

// string address = 1;
inline void RealMeta::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& RealMeta::address() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.RealMeta.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RealMeta::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:lb.czkatran.RealMeta.address)
}
inline std::string* RealMeta::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.RealMeta.address)
  return _s;
}
inline const std::string& RealMeta::_internal_address() const {
  return _impl_.address_.Get();
}
inline void RealMeta::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* RealMeta::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* RealMeta::release_address() {
  // @@protoc_insertion_point(field_release:lb.czkatran.RealMeta.address)
  return _impl_.address_.Release();
}
inline void RealMeta::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.RealMeta.address)
}

// int32 flags = 2;
inline void RealMeta::clear_flags() {
  _impl_.flags_ = 0;
}
inline int32_t RealMeta::_internal_flags() const {
  return _impl_.flags_;
}
inline int32_t RealMeta::flags() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.RealMeta.flags)
  return _internal_flags();
}
inline void RealMeta::_internal_set_flags(int32_t value) {
  
  _impl_.flags_ = value;
}
inline void RealMeta::set_flags(int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.RealMeta.flags)
}

// bool setflags = 3;
inline void RealMeta::clear_setflags() {
  _impl_.setflags_ = false;
}
inline bool RealMeta::_internal_setflags() const {
  return _impl_.setflags_;
}
inline bool RealMeta::setflags() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.RealMeta.setflags)
  return _internal_setflags();
}
inline void RealMeta::_internal_set_setflags(bool value) {
  
  _impl_.setflags_ = value;
}
inline void RealMeta::set_setflags(bool value) {
  _internal_set_setflags(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.RealMeta.setflags)
}

// -------------------------------------------------------------------

// Real

// string address = 1;
inline void Real::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Real::address() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Real.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Real::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:lb.czkatran.Real.address)
}
inline std::string* Real::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.Real.address)
  return _s;
}
inline const std::string& Real::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Real::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Real::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Real::release_address() {
  // @@protoc_insertion_point(field_release:lb.czkatran.Real.address)
  return _impl_.address_.Release();
}
inline void Real::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.Real.address)
}

// int32 weight = 2;
inline void Real::clear_weight() {
  _impl_.weight_ = 0;
}
inline int32_t Real::_internal_weight() const {
  return _impl_.weight_;
}
inline int32_t Real::weight() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Real.weight)
  return _internal_weight();
}
inline void Real::_internal_set_weight(int32_t value) {
  
  _impl_.weight_ = value;
}
inline void Real::set_weight(int32_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Real.weight)
}

// int32 flags = 3;
inline void Real::clear_flags() {
  _impl_.flags_ = 0;
}
inline int32_t Real::_internal_flags() const {
  return _impl_.flags_;
}
inline int32_t Real::flags() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Real.flags)
  return _internal_flags();
}
inline void Real::_internal_set_flags(int32_t value) {
  
  _impl_.flags_ = value;
}
inline void Real::set_flags(int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Real.flags)
}

// -------------------------------------------------------------------

// QuicReal

// string address = 1;
inline void QuicReal::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& QuicReal::address() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.QuicReal.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuicReal::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:lb.czkatran.QuicReal.address)
}
inline std::string* QuicReal::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.QuicReal.address)
  return _s;
}
inline const std::string& QuicReal::_internal_address() const {
  return _impl_.address_.Get();
}
inline void QuicReal::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* QuicReal::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* QuicReal::release_address() {
  // @@protoc_insertion_point(field_release:lb.czkatran.QuicReal.address)
  return _impl_.address_.Release();
}
inline void QuicReal::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.QuicReal.address)
}

// int32 id = 2;
inline void QuicReal::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t QuicReal::_internal_id() const {
  return _impl_.id_;
}
inline int32_t QuicReal::id() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.QuicReal.id)
  return _internal_id();
}
inline void QuicReal::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void QuicReal::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.QuicReal.id)
}

// -------------------------------------------------------------------

// Mac

// string mac = 1;
inline void Mac::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& Mac::mac() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Mac.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mac::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:lb.czkatran.Mac.mac)
}
inline std::string* Mac::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.Mac.mac)
  return _s;
}
inline const std::string& Mac::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void Mac::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* Mac::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* Mac::release_mac() {
  // @@protoc_insertion_point(field_release:lb.czkatran.Mac.mac)
  return _impl_.mac_.Release();
}
inline void Mac::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.Mac.mac)
}

// -------------------------------------------------------------------

// Stats

// uint64 v1 = 1;
inline void Stats::clear_v1() {
  _impl_.v1_ = uint64_t{0u};
}
inline uint64_t Stats::_internal_v1() const {
  return _impl_.v1_;
}
inline uint64_t Stats::v1() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Stats.v1)
  return _internal_v1();
}
inline void Stats::_internal_set_v1(uint64_t value) {
  
  _impl_.v1_ = value;
}
inline void Stats::set_v1(uint64_t value) {
  _internal_set_v1(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Stats.v1)
}

// uint64 v2 = 2;
inline void Stats::clear_v2() {
  _impl_.v2_ = uint64_t{0u};
}
inline uint64_t Stats::_internal_v2() const {
  return _impl_.v2_;
}
inline uint64_t Stats::v2() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Stats.v2)
  return _internal_v2();
}
inline void Stats::_internal_set_v2(uint64_t value) {
  
  _impl_.v2_ = value;
}
inline void Stats::set_v2(uint64_t value) {
  _internal_set_v2(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Stats.v2)
}

// -------------------------------------------------------------------

// Healthcheck

// uint32 somark = 1;
inline void Healthcheck::clear_somark() {
  _impl_.somark_ = 0u;
}
inline uint32_t Healthcheck::_internal_somark() const {
  return _impl_.somark_;
}
inline uint32_t Healthcheck::somark() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Healthcheck.somark)
  return _internal_somark();
}
inline void Healthcheck::_internal_set_somark(uint32_t value) {
  
  _impl_.somark_ = value;
}
inline void Healthcheck::set_somark(uint32_t value) {
  _internal_set_somark(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Healthcheck.somark)
}

// string address = 2;
inline void Healthcheck::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Healthcheck::address() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Healthcheck.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Healthcheck::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:lb.czkatran.Healthcheck.address)
}
inline std::string* Healthcheck::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.Healthcheck.address)
  return _s;
}
inline const std::string& Healthcheck::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Healthcheck::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Healthcheck::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* Healthcheck::release_address() {
  // @@protoc_insertion_point(field_release:lb.czkatran.Healthcheck.address)
  return _impl_.address_.Release();
}
inline void Healthcheck::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.Healthcheck.address)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// hcMap

// map<int32, string> healthchecks = 1;
inline int hcMap::_internal_healthchecks_size() const {
  return _impl_.healthchecks_.size();
}
inline int hcMap::healthchecks_size() const {
  return _internal_healthchecks_size();
}
inline void hcMap::clear_healthchecks() {
  _impl_.healthchecks_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
hcMap::_internal_healthchecks() const {
  return _impl_.healthchecks_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
hcMap::healthchecks() const {
  // @@protoc_insertion_point(field_map:lb.czkatran.hcMap.healthchecks)
  return _internal_healthchecks();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
hcMap::_internal_mutable_healthchecks() {
  return _impl_.healthchecks_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
hcMap::mutable_healthchecks() {
  // @@protoc_insertion_point(field_mutable_map:lb.czkatran.hcMap.healthchecks)
  return _internal_mutable_healthchecks();
}

// -------------------------------------------------------------------

// Reals

// repeated .lb.czkatran.Real reals = 1;
inline int Reals::_internal_reals_size() const {
  return _impl_.reals_.size();
}
inline int Reals::reals_size() const {
  return _internal_reals_size();
}
inline void Reals::clear_reals() {
  _impl_.reals_.Clear();
}
inline ::lb::czkatran::Real* Reals::mutable_reals(int index) {
  // @@protoc_insertion_point(field_mutable:lb.czkatran.Reals.reals)
  return _impl_.reals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Real >*
Reals::mutable_reals() {
  // @@protoc_insertion_point(field_mutable_list:lb.czkatran.Reals.reals)
  return &_impl_.reals_;
}
inline const ::lb::czkatran::Real& Reals::_internal_reals(int index) const {
  return _impl_.reals_.Get(index);
}
inline const ::lb::czkatran::Real& Reals::reals(int index) const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Reals.reals)
  return _internal_reals(index);
}
inline ::lb::czkatran::Real* Reals::_internal_add_reals() {
  return _impl_.reals_.Add();
}
inline ::lb::czkatran::Real* Reals::add_reals() {
  ::lb::czkatran::Real* _add = _internal_add_reals();
  // @@protoc_insertion_point(field_add:lb.czkatran.Reals.reals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Real >&
Reals::reals() const {
  // @@protoc_insertion_point(field_list:lb.czkatran.Reals.reals)
  return _impl_.reals_;
}

// -------------------------------------------------------------------

// Vips

// repeated .lb.czkatran.Vip vips = 1;
inline int Vips::_internal_vips_size() const {
  return _impl_.vips_.size();
}
inline int Vips::vips_size() const {
  return _internal_vips_size();
}
inline void Vips::clear_vips() {
  _impl_.vips_.Clear();
}
inline ::lb::czkatran::Vip* Vips::mutable_vips(int index) {
  // @@protoc_insertion_point(field_mutable:lb.czkatran.Vips.vips)
  return _impl_.vips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Vip >*
Vips::mutable_vips() {
  // @@protoc_insertion_point(field_mutable_list:lb.czkatran.Vips.vips)
  return &_impl_.vips_;
}
inline const ::lb::czkatran::Vip& Vips::_internal_vips(int index) const {
  return _impl_.vips_.Get(index);
}
inline const ::lb::czkatran::Vip& Vips::vips(int index) const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Vips.vips)
  return _internal_vips(index);
}
inline ::lb::czkatran::Vip* Vips::_internal_add_vips() {
  return _impl_.vips_.Add();
}
inline ::lb::czkatran::Vip* Vips::add_vips() {
  ::lb::czkatran::Vip* _add = _internal_add_vips();
  // @@protoc_insertion_point(field_add:lb.czkatran.Vips.vips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::Vip >&
Vips::vips() const {
  // @@protoc_insertion_point(field_list:lb.czkatran.Vips.vips)
  return _impl_.vips_;
}

// -------------------------------------------------------------------

// QuicReals

// repeated .lb.czkatran.QuicReal qreals = 1;
inline int QuicReals::_internal_qreals_size() const {
  return _impl_.qreals_.size();
}
inline int QuicReals::qreals_size() const {
  return _internal_qreals_size();
}
inline void QuicReals::clear_qreals() {
  _impl_.qreals_.Clear();
}
inline ::lb::czkatran::QuicReal* QuicReals::mutable_qreals(int index) {
  // @@protoc_insertion_point(field_mutable:lb.czkatran.QuicReals.qreals)
  return _impl_.qreals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::QuicReal >*
QuicReals::mutable_qreals() {
  // @@protoc_insertion_point(field_mutable_list:lb.czkatran.QuicReals.qreals)
  return &_impl_.qreals_;
}
inline const ::lb::czkatran::QuicReal& QuicReals::_internal_qreals(int index) const {
  return _impl_.qreals_.Get(index);
}
inline const ::lb::czkatran::QuicReal& QuicReals::qreals(int index) const {
  // @@protoc_insertion_point(field_get:lb.czkatran.QuicReals.qreals)
  return _internal_qreals(index);
}
inline ::lb::czkatran::QuicReal* QuicReals::_internal_add_qreals() {
  return _impl_.qreals_.Add();
}
inline ::lb::czkatran::QuicReal* QuicReals::add_qreals() {
  ::lb::czkatran::QuicReal* _add = _internal_add_qreals();
  // @@protoc_insertion_point(field_add:lb.czkatran.QuicReals.qreals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lb::czkatran::QuicReal >&
QuicReals::qreals() const {
  // @@protoc_insertion_point(field_list:lb.czkatran.QuicReals.qreals)
  return _impl_.qreals_;
}

// -------------------------------------------------------------------

// ModifiedRealForVip

// .lb.czkatran.Action action = 1;
inline void ModifiedRealForVip::clear_action() {
  _impl_.action_ = 0;
}
inline ::lb::czkatran::Action ModifiedRealForVip::_internal_action() const {
  return static_cast< ::lb::czkatran::Action >(_impl_.action_);
}
inline ::lb::czkatran::Action ModifiedRealForVip::action() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.ModifiedRealForVip.action)
  return _internal_action();
}
inline void ModifiedRealForVip::_internal_set_action(::lb::czkatran::Action value) {
  
  _impl_.action_ = value;
}
inline void ModifiedRealForVip::set_action(::lb::czkatran::Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.ModifiedRealForVip.action)
}

// .lb.czkatran.Reals real = 2;
inline bool ModifiedRealForVip::_internal_has_real() const {
  return this != internal_default_instance() && _impl_.real_ != nullptr;
}
inline bool ModifiedRealForVip::has_real() const {
  return _internal_has_real();
}
inline void ModifiedRealForVip::clear_real() {
  if (GetArenaForAllocation() == nullptr && _impl_.real_ != nullptr) {
    delete _impl_.real_;
  }
  _impl_.real_ = nullptr;
}
inline const ::lb::czkatran::Reals& ModifiedRealForVip::_internal_real() const {
  const ::lb::czkatran::Reals* p = _impl_.real_;
  return p != nullptr ? *p : reinterpret_cast<const ::lb::czkatran::Reals&>(
      ::lb::czkatran::_Reals_default_instance_);
}
inline const ::lb::czkatran::Reals& ModifiedRealForVip::real() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.ModifiedRealForVip.real)
  return _internal_real();
}
inline void ModifiedRealForVip::unsafe_arena_set_allocated_real(
    ::lb::czkatran::Reals* real) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.real_);
  }
  _impl_.real_ = real;
  if (real) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lb.czkatran.ModifiedRealForVip.real)
}
inline ::lb::czkatran::Reals* ModifiedRealForVip::release_real() {
  
  ::lb::czkatran::Reals* temp = _impl_.real_;
  _impl_.real_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::lb::czkatran::Reals* ModifiedRealForVip::unsafe_arena_release_real() {
  // @@protoc_insertion_point(field_release:lb.czkatran.ModifiedRealForVip.real)
  
  ::lb::czkatran::Reals* temp = _impl_.real_;
  _impl_.real_ = nullptr;
  return temp;
}
inline ::lb::czkatran::Reals* ModifiedRealForVip::_internal_mutable_real() {
  
  if (_impl_.real_ == nullptr) {
    auto* p = CreateMaybeMessage<::lb::czkatran::Reals>(GetArenaForAllocation());
    _impl_.real_ = p;
  }
  return _impl_.real_;
}
inline ::lb::czkatran::Reals* ModifiedRealForVip::mutable_real() {
  ::lb::czkatran::Reals* _msg = _internal_mutable_real();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.ModifiedRealForVip.real)
  return _msg;
}
inline void ModifiedRealForVip::set_allocated_real(::lb::czkatran::Reals* real) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.real_;
  }
  if (real) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(real);
    if (message_arena != submessage_arena) {
      real = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, real, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.real_ = real;
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.ModifiedRealForVip.real)
}

// .lb.czkatran.Vip vip = 3;
inline bool ModifiedRealForVip::_internal_has_vip() const {
  return this != internal_default_instance() && _impl_.vip_ != nullptr;
}
inline bool ModifiedRealForVip::has_vip() const {
  return _internal_has_vip();
}
inline void ModifiedRealForVip::clear_vip() {
  if (GetArenaForAllocation() == nullptr && _impl_.vip_ != nullptr) {
    delete _impl_.vip_;
  }
  _impl_.vip_ = nullptr;
}
inline const ::lb::czkatran::Vip& ModifiedRealForVip::_internal_vip() const {
  const ::lb::czkatran::Vip* p = _impl_.vip_;
  return p != nullptr ? *p : reinterpret_cast<const ::lb::czkatran::Vip&>(
      ::lb::czkatran::_Vip_default_instance_);
}
inline const ::lb::czkatran::Vip& ModifiedRealForVip::vip() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.ModifiedRealForVip.vip)
  return _internal_vip();
}
inline void ModifiedRealForVip::unsafe_arena_set_allocated_vip(
    ::lb::czkatran::Vip* vip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vip_);
  }
  _impl_.vip_ = vip;
  if (vip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lb.czkatran.ModifiedRealForVip.vip)
}
inline ::lb::czkatran::Vip* ModifiedRealForVip::release_vip() {
  
  ::lb::czkatran::Vip* temp = _impl_.vip_;
  _impl_.vip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::lb::czkatran::Vip* ModifiedRealForVip::unsafe_arena_release_vip() {
  // @@protoc_insertion_point(field_release:lb.czkatran.ModifiedRealForVip.vip)
  
  ::lb::czkatran::Vip* temp = _impl_.vip_;
  _impl_.vip_ = nullptr;
  return temp;
}
inline ::lb::czkatran::Vip* ModifiedRealForVip::_internal_mutable_vip() {
  
  if (_impl_.vip_ == nullptr) {
    auto* p = CreateMaybeMessage<::lb::czkatran::Vip>(GetArenaForAllocation());
    _impl_.vip_ = p;
  }
  return _impl_.vip_;
}
inline ::lb::czkatran::Vip* ModifiedRealForVip::mutable_vip() {
  ::lb::czkatran::Vip* _msg = _internal_mutable_vip();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.ModifiedRealForVip.vip)
  return _msg;
}
inline void ModifiedRealForVip::set_allocated_vip(::lb::czkatran::Vip* vip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vip_;
  }
  if (vip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vip);
    if (message_arena != submessage_arena) {
      vip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vip_ = vip;
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.ModifiedRealForVip.vip)
}

// -------------------------------------------------------------------

// ModifiedQuicReals

// .lb.czkatran.Action action = 1;
inline void ModifiedQuicReals::clear_action() {
  _impl_.action_ = 0;
}
inline ::lb::czkatran::Action ModifiedQuicReals::_internal_action() const {
  return static_cast< ::lb::czkatran::Action >(_impl_.action_);
}
inline ::lb::czkatran::Action ModifiedQuicReals::action() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.ModifiedQuicReals.action)
  return _internal_action();
}
inline void ModifiedQuicReals::_internal_set_action(::lb::czkatran::Action value) {
  
  _impl_.action_ = value;
}
inline void ModifiedQuicReals::set_action(::lb::czkatran::Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.ModifiedQuicReals.action)
}

// .lb.czkatran.QuicReals qreals = 2;
inline bool ModifiedQuicReals::_internal_has_qreals() const {
  return this != internal_default_instance() && _impl_.qreals_ != nullptr;
}
inline bool ModifiedQuicReals::has_qreals() const {
  return _internal_has_qreals();
}
inline void ModifiedQuicReals::clear_qreals() {
  if (GetArenaForAllocation() == nullptr && _impl_.qreals_ != nullptr) {
    delete _impl_.qreals_;
  }
  _impl_.qreals_ = nullptr;
}
inline const ::lb::czkatran::QuicReals& ModifiedQuicReals::_internal_qreals() const {
  const ::lb::czkatran::QuicReals* p = _impl_.qreals_;
  return p != nullptr ? *p : reinterpret_cast<const ::lb::czkatran::QuicReals&>(
      ::lb::czkatran::_QuicReals_default_instance_);
}
inline const ::lb::czkatran::QuicReals& ModifiedQuicReals::qreals() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.ModifiedQuicReals.qreals)
  return _internal_qreals();
}
inline void ModifiedQuicReals::unsafe_arena_set_allocated_qreals(
    ::lb::czkatran::QuicReals* qreals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.qreals_);
  }
  _impl_.qreals_ = qreals;
  if (qreals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lb.czkatran.ModifiedQuicReals.qreals)
}
inline ::lb::czkatran::QuicReals* ModifiedQuicReals::release_qreals() {
  
  ::lb::czkatran::QuicReals* temp = _impl_.qreals_;
  _impl_.qreals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::lb::czkatran::QuicReals* ModifiedQuicReals::unsafe_arena_release_qreals() {
  // @@protoc_insertion_point(field_release:lb.czkatran.ModifiedQuicReals.qreals)
  
  ::lb::czkatran::QuicReals* temp = _impl_.qreals_;
  _impl_.qreals_ = nullptr;
  return temp;
}
inline ::lb::czkatran::QuicReals* ModifiedQuicReals::_internal_mutable_qreals() {
  
  if (_impl_.qreals_ == nullptr) {
    auto* p = CreateMaybeMessage<::lb::czkatran::QuicReals>(GetArenaForAllocation());
    _impl_.qreals_ = p;
  }
  return _impl_.qreals_;
}
inline ::lb::czkatran::QuicReals* ModifiedQuicReals::mutable_qreals() {
  ::lb::czkatran::QuicReals* _msg = _internal_mutable_qreals();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.ModifiedQuicReals.qreals)
  return _msg;
}
inline void ModifiedQuicReals::set_allocated_qreals(::lb::czkatran::QuicReals* qreals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.qreals_;
  }
  if (qreals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qreals);
    if (message_arena != submessage_arena) {
      qreals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qreals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.qreals_ = qreals;
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.ModifiedQuicReals.qreals)
}

// -------------------------------------------------------------------

// realForVip

// .lb.czkatran.Real real = 1;
inline bool realForVip::_internal_has_real() const {
  return this != internal_default_instance() && _impl_.real_ != nullptr;
}
inline bool realForVip::has_real() const {
  return _internal_has_real();
}
inline void realForVip::clear_real() {
  if (GetArenaForAllocation() == nullptr && _impl_.real_ != nullptr) {
    delete _impl_.real_;
  }
  _impl_.real_ = nullptr;
}
inline const ::lb::czkatran::Real& realForVip::_internal_real() const {
  const ::lb::czkatran::Real* p = _impl_.real_;
  return p != nullptr ? *p : reinterpret_cast<const ::lb::czkatran::Real&>(
      ::lb::czkatran::_Real_default_instance_);
}
inline const ::lb::czkatran::Real& realForVip::real() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.realForVip.real)
  return _internal_real();
}
inline void realForVip::unsafe_arena_set_allocated_real(
    ::lb::czkatran::Real* real) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.real_);
  }
  _impl_.real_ = real;
  if (real) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lb.czkatran.realForVip.real)
}
inline ::lb::czkatran::Real* realForVip::release_real() {
  
  ::lb::czkatran::Real* temp = _impl_.real_;
  _impl_.real_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::lb::czkatran::Real* realForVip::unsafe_arena_release_real() {
  // @@protoc_insertion_point(field_release:lb.czkatran.realForVip.real)
  
  ::lb::czkatran::Real* temp = _impl_.real_;
  _impl_.real_ = nullptr;
  return temp;
}
inline ::lb::czkatran::Real* realForVip::_internal_mutable_real() {
  
  if (_impl_.real_ == nullptr) {
    auto* p = CreateMaybeMessage<::lb::czkatran::Real>(GetArenaForAllocation());
    _impl_.real_ = p;
  }
  return _impl_.real_;
}
inline ::lb::czkatran::Real* realForVip::mutable_real() {
  ::lb::czkatran::Real* _msg = _internal_mutable_real();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.realForVip.real)
  return _msg;
}
inline void realForVip::set_allocated_real(::lb::czkatran::Real* real) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.real_;
  }
  if (real) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(real);
    if (message_arena != submessage_arena) {
      real = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, real, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.real_ = real;
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.realForVip.real)
}

// .lb.czkatran.Vip vip = 2;
inline bool realForVip::_internal_has_vip() const {
  return this != internal_default_instance() && _impl_.vip_ != nullptr;
}
inline bool realForVip::has_vip() const {
  return _internal_has_vip();
}
inline void realForVip::clear_vip() {
  if (GetArenaForAllocation() == nullptr && _impl_.vip_ != nullptr) {
    delete _impl_.vip_;
  }
  _impl_.vip_ = nullptr;
}
inline const ::lb::czkatran::Vip& realForVip::_internal_vip() const {
  const ::lb::czkatran::Vip* p = _impl_.vip_;
  return p != nullptr ? *p : reinterpret_cast<const ::lb::czkatran::Vip&>(
      ::lb::czkatran::_Vip_default_instance_);
}
inline const ::lb::czkatran::Vip& realForVip::vip() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.realForVip.vip)
  return _internal_vip();
}
inline void realForVip::unsafe_arena_set_allocated_vip(
    ::lb::czkatran::Vip* vip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vip_);
  }
  _impl_.vip_ = vip;
  if (vip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lb.czkatran.realForVip.vip)
}
inline ::lb::czkatran::Vip* realForVip::release_vip() {
  
  ::lb::czkatran::Vip* temp = _impl_.vip_;
  _impl_.vip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::lb::czkatran::Vip* realForVip::unsafe_arena_release_vip() {
  // @@protoc_insertion_point(field_release:lb.czkatran.realForVip.vip)
  
  ::lb::czkatran::Vip* temp = _impl_.vip_;
  _impl_.vip_ = nullptr;
  return temp;
}
inline ::lb::czkatran::Vip* realForVip::_internal_mutable_vip() {
  
  if (_impl_.vip_ == nullptr) {
    auto* p = CreateMaybeMessage<::lb::czkatran::Vip>(GetArenaForAllocation());
    _impl_.vip_ = p;
  }
  return _impl_.vip_;
}
inline ::lb::czkatran::Vip* realForVip::mutable_vip() {
  ::lb::czkatran::Vip* _msg = _internal_mutable_vip();
  // @@protoc_insertion_point(field_mutable:lb.czkatran.realForVip.vip)
  return _msg;
}
inline void realForVip::set_allocated_vip(::lb::czkatran::Vip* vip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vip_;
  }
  if (vip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vip);
    if (message_arena != submessage_arena) {
      vip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vip_ = vip;
  // @@protoc_insertion_point(field_set_allocated:lb.czkatran.realForVip.vip)
}

// -------------------------------------------------------------------

// Flags

// uint64 flags = 1;
inline void Flags::clear_flags() {
  _impl_.flags_ = uint64_t{0u};
}
inline uint64_t Flags::_internal_flags() const {
  return _impl_.flags_;
}
inline uint64_t Flags::flags() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Flags.flags)
  return _internal_flags();
}
inline void Flags::_internal_set_flags(uint64_t value) {
  
  _impl_.flags_ = value;
}
inline void Flags::set_flags(uint64_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Flags.flags)
}

// -------------------------------------------------------------------

// Somark

// uint32 somark = 1;
inline void Somark::clear_somark() {
  _impl_.somark_ = 0u;
}
inline uint32_t Somark::_internal_somark() const {
  return _impl_.somark_;
}
inline uint32_t Somark::somark() const {
  // @@protoc_insertion_point(field_get:lb.czkatran.Somark.somark)
  return _internal_somark();
}
inline void Somark::_internal_set_somark(uint32_t value) {
  
  _impl_.somark_ = value;
}
inline void Somark::set_somark(uint32_t value) {
  _internal_set_somark(value);
  // @@protoc_insertion_point(field_set:lb.czkatran.Somark.somark)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace czkatran
}  // namespace lb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::lb::czkatran::Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lb::czkatran::Action>() {
  return ::lb::czkatran::Action_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_czkatran_2eproto
